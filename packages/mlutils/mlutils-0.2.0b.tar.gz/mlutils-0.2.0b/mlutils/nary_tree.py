#!/usr/bin/python
""" Implementation of generic N-ary search tree 
"""
import random
import re

class NAryTreeError(Exception):
    """ NAryTree exception
    """
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)
       
class NAryTreeNode:
    """ Generic N-ary tree node 
    """
    def __init__(self, node_data, parent = None):
        self.data = node_data
        self.parent = parent
        self.child_list = []
         
    def __str__(self, indent = ""):
        """ Print tree in hierarchy format 
        """    
        ret_str = str(self.data) + '\n'
        for ch in self.child_list:
            ret_str += "|" + indent + "->" + ch.__str__(" |" + indent)
        return ret_str 
    
    def __cmp__(self, other):
        """ Default comparison function for NAryTreeNode objects
        """
        if isinstance(other, NAryTreeNode):
            if self.data < other.data:
                return -1
            else:
                return self.data > other.data    
        else:
            if self.data < other:
                return -1
            else:
                return self.data > other
           
    def add(self, obj):
        """ If <obj> is NAryTreeNode it join two NAry trees
            otherwise create new child node from data object and add it to current node
            return added node
        """
        if isinstance(obj, NAryTreeNode):
            obj.parent = self
            self.child_list.append(obj)
            return obj
        else:
            ch = NAryTreeNode(obj, self)
            self.child_list.append(ch)
            return ch
         
    def build_tree(self, generator_func, depth):
        """ Build tree from new node data generated by <generator_func> for current node
                <generator_func> will be called as generator_func(self.data)
                it should return sequence of child data for current node
        """
        if depth: 
            for node_data in generator_func(self.data):
                ch = self.add(node_data)
                ch.build_tree(generator_func, depth-1)    
            
    def sort(self, comparison_func = None):
        """ Sort node's child_list according to custom <comparison_func> 
            if <comparison_func> is not specified default comparison operation will be used 
        """
        self.child_list.sort(comparison_func)
        for node in self.child_list:
            node.sort(comparison_func)             
                           
    def reset(self):
        """ Reset node flag to default state(0)
        """
        self.flag = 0
        for node in self.child_list:
            node.reset()
            
    def path(self):
        """ Return list with node_data of all nodes on the path to current node from tree root
        """
        if self.parent:
            path = self.parent.path()
            path.append(self.data)
            return path
        else:
            return [self.data]

    def print_path(self):
        """ Print node path in hierarchy format 
        """
        i = 0    
        s = ""
        if self.parent:
            i += self.parent.print_path() 
        if i: s = " "*3*(i-1)+"|->"
        print  s + str(self.data)
        return i+1

                
    def level(self):
        """ Return level of the current node
        """
        return len(self.path())-1
                       
    def preorder_search(self, test_func):
        """ Depth-first pre-order tree search routine. 
                if succeed return found tree node, otherwise return None
            <test_func> is test to perform on each visited node of the tree as "test_func(self.data)"
                it should return True to terminate search or False or None to keep search tree 
        """        
        if test_func(self.data): 
            return self
        for node in self.child_list:
            rc = node.preorder_search(test_func)
            if rc: return rc
                                         
    def postorder_search(self, test_func):                                                    
        """ Depth-first post-order tree search routine. 
                if succeed return found tree node, otherwise return None
            <test_func> is test to perform on each visited node of the tree as "test_func(self.data)"
                it should return True to terminate search or False or None to keep search tree 
        """  
        for node in self.child_list:
            rc = node.postorder_search(test_func)
            if rc: 
                return rc
        if test_func(self.data): 
            return self
        
    def breadth_first_search(self, test_func, search_list = None):
        """ Breadth first tree search routine
                if succeed return found tree node, otherwise return None
            <test_func> is test to perform on each visited node of the tree as "test_func(self.data)"
                it should return True to terminate search or False or None to keep search tree 
        """
        if search_list == None:
            search_list = [self]
            
        search_list_next = []
        for node in search_list:
            if test_func(node.data): 
                return node
            else:
                search_list_next.extend(node.child_list)
        if len(search_list_next) > 0 :
            rc = self.breadth_first_search(test_func, search_list_next) 
            if rc: 
                return rc   
            
    def heuristic_search(self, test_func, heuristic_func):          
        """ Heuristic tree search routine. 
                if succeed return found tree node, otherwise return None
            <test_func> is test to perform on each visited node of the tree as "test_func(self.data)"
                it should return True to terminate search or False or None to keep search tree 
            <heuristic_func>  will be called for each visited node as heuristic_func(node_list)
                it should return next node to visit or None for backward move                
        """  
        if test_func(self.data): 
            return self
        search_list = list(self.child_list)
        while len(search_list) > 0:
            node_to_search = heuristic_func(search_list)
            if node_to_search:
                rc = node_to_search.heuristic_search(test_func, heuristic_func)  
                if rc: 
                    return rc   
                else:
                    search_list.remove(node_to_search)
            else: 
                return None
    
    def random_sampling_search(self, test_func):
        """ Random sampling depth-first tree search routine. 
                if succeed return found tree node, otherwise return None
            <test_func> is test to perform on each visited node of the tree as "test_func(self.data)"
                it should return True to terminate search or False or None to keep search tree 
        """  
        if test_func(self.data): 
            return self
        search_list = list(self.child_list)
        while len(search_list) > 0:
            node_to_search = random.sample(search_list, 1)
            rc = node_to_search[0].random_sampling_search(test_func)  
            if rc: 
                return rc   
            else:
                search_list.remove(node_to_search[0])
             
def test():
    """ Test/usage example
    """
    _trace = 1
    _template_seq = "ACGT_X"
    _target_seq = "AGT"
    _test_plan = {"pre-order" : 0, "post-order" : 0, "breadth-first" : 1, "heuristic" : 0, "random sampling" : 0}

    
    def get_node_data(node_list):
        rl = []
        for node in node_list:
            rl.append(node.data)
        return rl    
    
    def build_func(state):
        num = random.randrange(3,5)
        population = list(state) + list(_template_seq)
        while(num):
            l = random.sample(population, len(state)+1)
            out_str = ""
            for s in l: out_str += str(s)
            yield out_str
            num -=1 
          
    def comparison_func(a, b):
        if len(a.data) < len(b.data):
            return -1
        elif len(a.data) == len(b.data):
            return 0
        else:
            return 1
        
    def test_func(state):
        if _trace : print "--- trace in test_func(): ", state
        return re.search(_target_seq, state) != None 
                
    def heuristic_func(node_list):
        if _trace :  print "--- trace in heuristic_func(): ", get_node_data(node_list)
        for node in node_list:
            if re.search(_target_seq[0], node.data) != None:
                return node
    
    root = NAryTreeNode("GTCA")
    root.build_tree(build_func, 2)
    n = root.add(NAryTreeNode("AC__"))
    n2 = n.add("A_T_")
    #print root.data, "has level:",root.level(), "path:", root.path()
    #print n2.data, "has level:", n2.level(), "path:", n2.path()
    
    #root.sort(comparison_func)
    #root.sort()
    print root  
      
    if _test_plan["pre-order"]:
        print "\n# pre-order search"
        node = root.preorder_search(test_func)     
        if node:    
            print "found path: %s" % node.path()
    
    if _test_plan["post-order"]:
        print "\n# post-order search"
        node = root.postorder_search(test_func)     
        if node:    
            print "found path: %s" % node.path()
    
    if _test_plan["breadth-first"]:
        print "\n# breadth-first search"
        node = root.breadth_first_search(test_func)     
        if node:    
            print "fount path: %s" % node.path()
    
    if _test_plan["heuristic"]:
        print "\n# heuristic search"           
        node = root.heuristic_search(test_func, heuristic_func)    
        if node:    
            print "found path: %s" % node.path()
    
    if _test_plan["random sampling"]:    
        print "\n# random sampling search"                     
        node = root.random_sampling_search(test_func)    
        if node:    
            print "found path: %s" % node.path()
        
if __name__ == '__main__':
    test()
            