import os

import networkx as nx

from attacksurfacemeter import utilities
from attacksurfacemeter.call import Call
from attacksurfacemeter.granularity import Granularity
from attacksurfacemeter.loaders.base_loader import BaseLoader

HEADER = "index % time    self  children    called     name\n"
SEPARATOR = "-----------------------------------------------\n"
EOF = "\x0c\n"


class GprofLoader(BaseLoader):
    """"""

    def __init__(self, source, reverse=False, defenses=None,
                 vulnerabilities=None):
        """Constructor for GprofParser.

        Parameters
        ----------
        source : str
            The absolute path to a text file containing the call graph
            generated using gprof.
        reverse : bool, optional
            Parameter irrelevant.
        defenses : list, optional
            A list of Call objects, each representing a designed defense in the
            system.
        vulnerabilities : list, optional
            A list of Call objects, each representing a vulnerable function in
            the system.
        """
        super(GprofLoader, self).__init__(
            source, reverse, defenses, vulnerabilities
        )

    def load_call_graph(self, granularity=Granularity.FUNC):
        """Load a call graph generated by gprof.

        Parameters
        ----------
        granularity : str
            The granularity at which the call graph must be loaded. See
            attacksurfacemeter.granularity.Granularity for available choices.

        Returns
        -------
        call_graph : networkx.DiGraph
            An object representing the call graph.
        """
        call_graph = nx.DiGraph()

        header_passed = False

        function = None

        is_caller = True
        callers = list()
        callees = list()

        # A typical gprof call graph follows the pattern shown below:
        #
        #   HEADER
        #       callers
        #   function
        #       [callees]
        #   SEPARATOR
        #   ...
        #   EOF
        with open(self.source) as raw_call_graph:
            # Fast-forwarding the file pointer to the line after the header
            for line in raw_call_graph:
                if line == HEADER:
                    break

            for line in raw_call_graph:
                if line.startswith('['):
                    # gprof function line
                    function = Call.from_gprof(line, granularity)
                    is_caller = False
                elif line == SEPARATOR:
                    for caller in callers:
                        (caller_attrs, callee_attrs) = (
                            utilities.get_node_attrs(
                                'gprof', caller, function, self.defenses,
                                self.vulnerabilities
                            )
                        )

                        call_graph.add_node(caller, caller_attrs)

                        if callee_attrs is not None:
                            call_graph.add_node(function, callee_attrs)

                            # Adding the edge caller --  callee
                            attrs = {'gprof': None, 'call': None}
                            call_graph.add_edge(caller, function, attrs)

                            # Adding the edge callee -- caller with the
                            #   assumption that every call must return
                            attrs = {'gprof': None, 'return': None}
                            call_graph.add_edge(function, caller, attrs)

                    (function_attrs, _) = utilities.get_node_attrs(
                        'gprof', function, None, self.defenses,
                        self.vulnerabilities
                    )
                    call_graph.add_node(function, function_attrs)

                    for callee in callees:
                        (caller_attrs, callee_attrs) = (
                            utilities.get_node_attrs(
                                'gprof', function, callee, self.defenses,
                                self.vulnerabilities
                            )
                        )

                        call_graph.add_node(function, caller_attrs)

                        if callee_attrs is not None:
                            call_graph.add_node(callee, callee_attrs)

                            # Adding the edge caller --  callee
                            attrs = {'gprof': None, 'call': None}
                            call_graph.add_edge(function, callee, attrs)

                            # Adding the edge callee -- caller with the
                            #   assumption that every call must return
                            attrs = {'gprof': None, 'return': None}
                            call_graph.add_edge(callee, function, attrs)

                    is_caller = True
                    callers.clear()
                    callees.clear()
                elif line == EOF:
                    break
                else:
                    try:
                        if is_caller:
                            # gprof caller line
                            callers.append(Call.from_gprof(line, granularity))
                        else:
                            # gprof callee line
                            callees.append(Call.from_gprof(line, granularity))
                    except ValueError as e:
                        self._errors.append(
                            "Error: " + str(e) + " Input line: " + line
                        )

        return call_graph
