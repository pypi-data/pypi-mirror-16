# Generated from grammar/SignalFlowV2.g4 by ANTLR 4.5.1
# encoding: utf-8
from __future__ import print_function
from antlr4 import *
from io import StringIO

def serializedATN():
    with StringIO() as buf:
        buf.write(u"\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3")
        buf.write(u"*\u00ca\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t")
        buf.write(u"\7\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r")
        buf.write(u"\4\16\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4")
        buf.write(u"\23\t\23\4\24\t\24\4\25\t\25\3\2\7\2,\n\2\f\2\16\2/\13")
        buf.write(u"\2\3\2\3\2\3\3\5\3\64\n\3\3\3\3\3\3\4\5\49\n\4\3\4\5")
        buf.write(u"\4<\n\4\3\4\3\4\3\5\3\5\5\5B\n\5\3\5\3\5\3\6\3\6\3\6")
        buf.write(u"\3\6\3\6\3\6\5\6L\n\6\3\6\5\6O\n\6\3\7\3\7\3\7\3\7\3")
        buf.write(u"\7\3\b\3\b\3\b\7\bY\n\b\f\b\16\b\\\13\b\3\t\3\t\3\t\7")
        buf.write(u"\ta\n\t\f\t\16\td\13\t\3\n\3\n\3\n\5\ni\n\n\3\13\3\13")
        buf.write(u"\3\13\7\13n\n\13\f\13\16\13q\13\13\3\f\3\f\3\f\7\fv\n")
        buf.write(u"\f\f\f\16\fy\13\f\3\r\3\r\3\r\7\r~\n\r\f\r\16\r\u0081")
        buf.write(u"\13\r\3\16\3\16\3\16\5\16\u0086\n\16\3\17\3\17\3\17\5")
        buf.write(u"\17\u008b\n\17\3\20\3\20\7\20\u008f\n\20\f\20\16\20\u0092")
        buf.write(u"\13\20\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\6")
        buf.write(u"\21\u009d\n\21\r\21\16\21\u009e\3\21\3\21\3\21\5\21\u00a4")
        buf.write(u"\n\21\3\22\3\22\3\22\3\22\7\22\u00aa\n\22\f\22\16\22")
        buf.write(u"\u00ad\13\22\5\22\u00af\n\22\3\22\3\22\3\23\3\23\5\23")
        buf.write(u"\u00b5\n\23\3\23\3\23\3\23\5\23\u00ba\n\23\3\24\3\24")
        buf.write(u"\3\24\7\24\u00bf\n\24\f\24\16\24\u00c2\13\24\3\25\3\25")
        buf.write(u"\5\25\u00c6\n\25\3\25\3\25\3\25\2\2\26\2\4\6\b\n\f\16")
        buf.write(u"\20\22\24\26\30\32\34\36 \"$&(\2\5\3\2\f\21\3\2!\"\3")
        buf.write(u"\2#$\u00d4\2-\3\2\2\2\4\63\3\2\2\2\68\3\2\2\2\bA\3\2")
        buf.write(u"\2\2\nN\3\2\2\2\fP\3\2\2\2\16U\3\2\2\2\20]\3\2\2\2\22")
        buf.write(u"h\3\2\2\2\24j\3\2\2\2\26r\3\2\2\2\30z\3\2\2\2\32\u0085")
        buf.write(u"\3\2\2\2\34\u0087\3\2\2\2\36\u008c\3\2\2\2 \u00a3\3\2")
        buf.write(u"\2\2\"\u00a5\3\2\2\2$\u00b9\3\2\2\2&\u00bb\3\2\2\2(\u00c5")
        buf.write(u"\3\2\2\2*,\5\4\3\2+*\3\2\2\2,/\3\2\2\2-+\3\2\2\2-.\3")
        buf.write(u"\2\2\2.\60\3\2\2\2/-\3\2\2\2\60\61\5\6\4\2\61\3\3\2\2")
        buf.write(u"\2\62\64\5\b\5\2\63\62\3\2\2\2\63\64\3\2\2\2\64\65\3")
        buf.write(u"\2\2\2\65\66\7(\2\2\66\5\3\2\2\2\679\5\b\5\28\67\3\2")
        buf.write(u"\2\289\3\2\2\29;\3\2\2\2:<\7(\2\2;:\3\2\2\2;<\3\2\2\2")
        buf.write(u"<=\3\2\2\2=>\7\2\2\3>\7\3\2\2\2?@\7\25\2\2@B\7&\2\2A")
        buf.write(u"?\3\2\2\2AB\3\2\2\2BC\3\2\2\2CD\5\n\6\2D\t\3\2\2\2EK")
        buf.write(u"\5\16\b\2FG\7\7\2\2GH\5\16\b\2HI\7\b\2\2IJ\5\n\6\2JL")
        buf.write(u"\3\2\2\2KF\3\2\2\2KL\3\2\2\2LO\3\2\2\2MO\5\f\7\2NE\3")
        buf.write(u"\2\2\2NM\3\2\2\2O\13\3\2\2\2PQ\7\3\2\2QR\7\25\2\2RS\7")
        buf.write(u" \2\2ST\5\n\6\2T\r\3\2\2\2UZ\5\20\t\2VW\7\22\2\2WY\5")
        buf.write(u"\20\t\2XV\3\2\2\2Y\\\3\2\2\2ZX\3\2\2\2Z[\3\2\2\2[\17")
        buf.write(u"\3\2\2\2\\Z\3\2\2\2]b\5\22\n\2^_\7\23\2\2_a\5\22\n\2")
        buf.write(u"`^\3\2\2\2ad\3\2\2\2b`\3\2\2\2bc\3\2\2\2c\21\3\2\2\2")
        buf.write(u"db\3\2\2\2ef\7\24\2\2fi\5\22\n\2gi\5\24\13\2he\3\2\2")
        buf.write(u"\2hg\3\2\2\2i\23\3\2\2\2jo\5\26\f\2kl\t\2\2\2ln\5\26")
        buf.write(u"\f\2mk\3\2\2\2nq\3\2\2\2om\3\2\2\2op\3\2\2\2p\25\3\2")
        buf.write(u"\2\2qo\3\2\2\2rw\5\30\r\2st\t\3\2\2tv\5\30\r\2us\3\2")
        buf.write(u"\2\2vy\3\2\2\2wu\3\2\2\2wx\3\2\2\2x\27\3\2\2\2yw\3\2")
        buf.write(u"\2\2z\177\5\32\16\2{|\t\4\2\2|~\5\32\16\2}{\3\2\2\2~")
        buf.write(u"\u0081\3\2\2\2\177}\3\2\2\2\177\u0080\3\2\2\2\u0080\31")
        buf.write(u"\3\2\2\2\u0081\177\3\2\2\2\u0082\u0083\t\3\2\2\u0083")
        buf.write(u"\u0086\5\32\16\2\u0084\u0086\5\34\17\2\u0085\u0082\3")
        buf.write(u"\2\2\2\u0085\u0084\3\2\2\2\u0086\33\3\2\2\2\u0087\u008a")
        buf.write(u"\5\36\20\2\u0088\u0089\7%\2\2\u0089\u008b\5\32\16\2\u008a")
        buf.write(u"\u0088\3\2\2\2\u008a\u008b\3\2\2\2\u008b\35\3\2\2\2\u008c")
        buf.write(u"\u0090\5 \21\2\u008d\u008f\5$\23\2\u008e\u008d\3\2\2")
        buf.write(u"\2\u008f\u0092\3\2\2\2\u0090\u008e\3\2\2\2\u0090\u0091")
        buf.write(u"\3\2\2\2\u0091\37\3\2\2\2\u0092\u0090\3\2\2\2\u0093\u00a4")
        buf.write(u"\5\"\22\2\u0094\u0095\7\30\2\2\u0095\u0096\5\n\6\2\u0096")
        buf.write(u"\u0097\7\31\2\2\u0097\u00a4\3\2\2\2\u0098\u00a4\7\25")
        buf.write(u"\2\2\u0099\u00a4\7\t\2\2\u009a\u00a4\7\n\2\2\u009b\u009d")
        buf.write(u"\7\13\2\2\u009c\u009b\3\2\2\2\u009d\u009e\3\2\2\2\u009e")
        buf.write(u"\u009c\3\2\2\2\u009e\u009f\3\2\2\2\u009f\u00a4\3\2\2")
        buf.write(u"\2\u00a0\u00a4\7\4\2\2\u00a1\u00a4\7\5\2\2\u00a2\u00a4")
        buf.write(u"\7\6\2\2\u00a3\u0093\3\2\2\2\u00a3\u0094\3\2\2\2\u00a3")
        buf.write(u"\u0098\3\2\2\2\u00a3\u0099\3\2\2\2\u00a3\u009a\3\2\2")
        buf.write(u"\2\u00a3\u009c\3\2\2\2\u00a3\u00a0\3\2\2\2\u00a3\u00a1")
        buf.write(u"\3\2\2\2\u00a3\u00a2\3\2\2\2\u00a4!\3\2\2\2\u00a5\u00ae")
        buf.write(u"\7\32\2\2\u00a6\u00ab\5\n\6\2\u00a7\u00a8\7\36\2\2\u00a8")
        buf.write(u"\u00aa\5\n\6\2\u00a9\u00a7\3\2\2\2\u00aa\u00ad\3\2\2")
        buf.write(u"\2\u00ab\u00a9\3\2\2\2\u00ab\u00ac\3\2\2\2\u00ac\u00af")
        buf.write(u"\3\2\2\2\u00ad\u00ab\3\2\2\2\u00ae\u00a6\3\2\2\2\u00ae")
        buf.write(u"\u00af\3\2\2\2\u00af\u00b0\3\2\2\2\u00b0\u00b1\7\33\2")
        buf.write(u"\2\u00b1#\3\2\2\2\u00b2\u00b4\7\30\2\2\u00b3\u00b5\5")
        buf.write(u"&\24\2\u00b4\u00b3\3\2\2\2\u00b4\u00b5\3\2\2\2\u00b5")
        buf.write(u"\u00b6\3\2\2\2\u00b6\u00ba\7\31\2\2\u00b7\u00b8\7\'\2")
        buf.write(u"\2\u00b8\u00ba\7\25\2\2\u00b9\u00b2\3\2\2\2\u00b9\u00b7")
        buf.write(u"\3\2\2\2\u00ba%\3\2\2\2\u00bb\u00c0\5(\25\2\u00bc\u00bd")
        buf.write(u"\7\36\2\2\u00bd\u00bf\5(\25\2\u00be\u00bc\3\2\2\2\u00bf")
        buf.write(u"\u00c2\3\2\2\2\u00c0\u00be\3\2\2\2\u00c0\u00c1\3\2\2")
        buf.write(u"\2\u00c1\'\3\2\2\2\u00c2\u00c0\3\2\2\2\u00c3\u00c4\7")
        buf.write(u"\25\2\2\u00c4\u00c6\7&\2\2\u00c5\u00c3\3\2\2\2\u00c5")
        buf.write(u"\u00c6\3\2\2\2\u00c6\u00c7\3\2\2\2\u00c7\u00c8\5\n\6")
        buf.write(u"\2\u00c8)\3\2\2\2\32-\638;AKNZbhow\177\u0085\u008a\u0090")
        buf.write(u"\u009e\u00a3\u00ab\u00ae\u00b4\u00b9\u00c0\u00c5")
        return buf.getvalue()


class SignalFlowV2Parser ( Parser ):

    grammarFileName = "SignalFlowV2.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ u"<INVALID>", u"'lambda'", u"'None'", u"'True'", u"'False'", 
                     u"'if'", u"'else'", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"'<='", u"'>='", u"'=='", u"'!='", u"'<'", u"'>'", 
                     u"'or'", u"'and'", u"'not'", u"<INVALID>", u"'?'", 
                     u"'!'", u"'('", u"')'", u"'['", u"']'", u"'{'", u"'}'", 
                     u"','", u"';'", u"':'", u"'+'", u"'-'", u"'*'", u"'/'", 
                     u"'**'", u"'='", u"'.'", u"'\n'" ]

    symbolicNames = [ u"<INVALID>", u"LAMBDA", u"NONE", u"TRUE", u"FALSE", 
                      u"IF", u"ELSE", u"INT", u"FLOAT", u"STRING", u"LE", 
                      u"GE", u"EQ", u"NE", u"LT", u"GT", u"OR", u"AND", 
                      u"NOT", u"ID", u"QMARK", u"EXCL", u"LPAREN", u"RPAREN", 
                      u"LSQUARE", u"RSQUARE", u"LBRACE", u"RBRACE", u"COMMA", 
                      u"SEMICOLON", u"COLON", u"PLUS", u"MINUS", u"MUL", 
                      u"DIV", u"POW", u"BINDING", u"DOT", u"NEWLINE", u"WS", 
                      u"LINE_COMMENT" ]

    RULE_program = 0
    RULE_interior_line = 1
    RULE_last_line = 2
    RULE_statement = 3
    RULE_test = 4
    RULE_lambdef = 5
    RULE_or_test = 6
    RULE_and_test = 7
    RULE_not_test = 8
    RULE_comparison = 9
    RULE_expr = 10
    RULE_term = 11
    RULE_factor = 12
    RULE_power = 13
    RULE_atom_expr = 14
    RULE_atom = 15
    RULE_list_value = 16
    RULE_trailer = 17
    RULE_actual_args = 18
    RULE_argument = 19

    ruleNames =  [ u"program", u"interior_line", u"last_line", u"statement", 
                   u"test", u"lambdef", u"or_test", u"and_test", u"not_test", 
                   u"comparison", u"expr", u"term", u"factor", u"power", 
                   u"atom_expr", u"atom", u"list_value", u"trailer", u"actual_args", 
                   u"argument" ]

    EOF = Token.EOF
    LAMBDA=1
    NONE=2
    TRUE=3
    FALSE=4
    IF=5
    ELSE=6
    INT=7
    FLOAT=8
    STRING=9
    LE=10
    GE=11
    EQ=12
    NE=13
    LT=14
    GT=15
    OR=16
    AND=17
    NOT=18
    ID=19
    QMARK=20
    EXCL=21
    LPAREN=22
    RPAREN=23
    LSQUARE=24
    RSQUARE=25
    LBRACE=26
    RBRACE=27
    COMMA=28
    SEMICOLON=29
    COLON=30
    PLUS=31
    MINUS=32
    MUL=33
    DIV=34
    POW=35
    BINDING=36
    DOT=37
    NEWLINE=38
    WS=39
    LINE_COMMENT=40

    def __init__(self, input):
        super(SignalFlowV2Parser, self).__init__(input)
        self.checkVersion("4.5.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class ProgramContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SignalFlowV2Parser.ProgramContext, self).__init__(parent, invokingState)
            self.parser = parser

        def last_line(self):
            return self.getTypedRuleContext(SignalFlowV2Parser.Last_lineContext,0)


        def interior_line(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(SignalFlowV2Parser.Interior_lineContext)
            else:
                return self.getTypedRuleContext(SignalFlowV2Parser.Interior_lineContext,i)


        def getRuleIndex(self):
            return SignalFlowV2Parser.RULE_program

        def enterRule(self, listener):
            if hasattr(listener, "enterProgram"):
                listener.enterProgram(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitProgram"):
                listener.exitProgram(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitProgram"):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)




    def program(self):

        localctx = SignalFlowV2Parser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 43
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,0,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 40
                    self.interior_line() 
                self.state = 45
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,0,self._ctx)

            self.state = 46
            self.last_line()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Interior_lineContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SignalFlowV2Parser.Interior_lineContext, self).__init__(parent, invokingState)
            self.parser = parser

        def NEWLINE(self):
            return self.getToken(SignalFlowV2Parser.NEWLINE, 0)

        def statement(self):
            return self.getTypedRuleContext(SignalFlowV2Parser.StatementContext,0)


        def getRuleIndex(self):
            return SignalFlowV2Parser.RULE_interior_line

        def enterRule(self, listener):
            if hasattr(listener, "enterInterior_line"):
                listener.enterInterior_line(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitInterior_line"):
                listener.exitInterior_line(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitInterior_line"):
                return visitor.visitInterior_line(self)
            else:
                return visitor.visitChildren(self)




    def interior_line(self):

        localctx = SignalFlowV2Parser.Interior_lineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_interior_line)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 49
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SignalFlowV2Parser.LAMBDA) | (1 << SignalFlowV2Parser.NONE) | (1 << SignalFlowV2Parser.TRUE) | (1 << SignalFlowV2Parser.FALSE) | (1 << SignalFlowV2Parser.INT) | (1 << SignalFlowV2Parser.FLOAT) | (1 << SignalFlowV2Parser.STRING) | (1 << SignalFlowV2Parser.NOT) | (1 << SignalFlowV2Parser.ID) | (1 << SignalFlowV2Parser.LPAREN) | (1 << SignalFlowV2Parser.LSQUARE) | (1 << SignalFlowV2Parser.PLUS) | (1 << SignalFlowV2Parser.MINUS))) != 0):
                self.state = 48
                self.statement()


            self.state = 51
            self.match(SignalFlowV2Parser.NEWLINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Last_lineContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SignalFlowV2Parser.Last_lineContext, self).__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(SignalFlowV2Parser.EOF, 0)

        def statement(self):
            return self.getTypedRuleContext(SignalFlowV2Parser.StatementContext,0)


        def NEWLINE(self):
            return self.getToken(SignalFlowV2Parser.NEWLINE, 0)

        def getRuleIndex(self):
            return SignalFlowV2Parser.RULE_last_line

        def enterRule(self, listener):
            if hasattr(listener, "enterLast_line"):
                listener.enterLast_line(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLast_line"):
                listener.exitLast_line(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitLast_line"):
                return visitor.visitLast_line(self)
            else:
                return visitor.visitChildren(self)




    def last_line(self):

        localctx = SignalFlowV2Parser.Last_lineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_last_line)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 54
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SignalFlowV2Parser.LAMBDA) | (1 << SignalFlowV2Parser.NONE) | (1 << SignalFlowV2Parser.TRUE) | (1 << SignalFlowV2Parser.FALSE) | (1 << SignalFlowV2Parser.INT) | (1 << SignalFlowV2Parser.FLOAT) | (1 << SignalFlowV2Parser.STRING) | (1 << SignalFlowV2Parser.NOT) | (1 << SignalFlowV2Parser.ID) | (1 << SignalFlowV2Parser.LPAREN) | (1 << SignalFlowV2Parser.LSQUARE) | (1 << SignalFlowV2Parser.PLUS) | (1 << SignalFlowV2Parser.MINUS))) != 0):
                self.state = 53
                self.statement()


            self.state = 57
            _la = self._input.LA(1)
            if _la==SignalFlowV2Parser.NEWLINE:
                self.state = 56
                self.match(SignalFlowV2Parser.NEWLINE)


            self.state = 59
            self.match(SignalFlowV2Parser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatementContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SignalFlowV2Parser.StatementContext, self).__init__(parent, invokingState)
            self.parser = parser

        def test(self):
            return self.getTypedRuleContext(SignalFlowV2Parser.TestContext,0)


        def ID(self):
            return self.getToken(SignalFlowV2Parser.ID, 0)

        def BINDING(self):
            return self.getToken(SignalFlowV2Parser.BINDING, 0)

        def getRuleIndex(self):
            return SignalFlowV2Parser.RULE_statement

        def enterRule(self, listener):
            if hasattr(listener, "enterStatement"):
                listener.enterStatement(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitStatement"):
                listener.exitStatement(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitStatement"):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = SignalFlowV2Parser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 63
            la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
            if la_ == 1:
                self.state = 61
                self.match(SignalFlowV2Parser.ID)
                self.state = 62
                self.match(SignalFlowV2Parser.BINDING)


            self.state = 65
            self.test()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TestContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SignalFlowV2Parser.TestContext, self).__init__(parent, invokingState)
            self.parser = parser

        def or_test(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(SignalFlowV2Parser.Or_testContext)
            else:
                return self.getTypedRuleContext(SignalFlowV2Parser.Or_testContext,i)


        def IF(self):
            return self.getToken(SignalFlowV2Parser.IF, 0)

        def ELSE(self):
            return self.getToken(SignalFlowV2Parser.ELSE, 0)

        def test(self):
            return self.getTypedRuleContext(SignalFlowV2Parser.TestContext,0)


        def lambdef(self):
            return self.getTypedRuleContext(SignalFlowV2Parser.LambdefContext,0)


        def getRuleIndex(self):
            return SignalFlowV2Parser.RULE_test

        def enterRule(self, listener):
            if hasattr(listener, "enterTest"):
                listener.enterTest(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitTest"):
                listener.exitTest(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitTest"):
                return visitor.visitTest(self)
            else:
                return visitor.visitChildren(self)




    def test(self):

        localctx = SignalFlowV2Parser.TestContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_test)
        self._la = 0 # Token type
        try:
            self.state = 76
            token = self._input.LA(1)
            if token in [SignalFlowV2Parser.NONE, SignalFlowV2Parser.TRUE, SignalFlowV2Parser.FALSE, SignalFlowV2Parser.INT, SignalFlowV2Parser.FLOAT, SignalFlowV2Parser.STRING, SignalFlowV2Parser.NOT, SignalFlowV2Parser.ID, SignalFlowV2Parser.LPAREN, SignalFlowV2Parser.LSQUARE, SignalFlowV2Parser.PLUS, SignalFlowV2Parser.MINUS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 67
                self.or_test()
                self.state = 73
                _la = self._input.LA(1)
                if _la==SignalFlowV2Parser.IF:
                    self.state = 68
                    self.match(SignalFlowV2Parser.IF)
                    self.state = 69
                    self.or_test()
                    self.state = 70
                    self.match(SignalFlowV2Parser.ELSE)
                    self.state = 71
                    self.test()



            elif token in [SignalFlowV2Parser.LAMBDA]:
                self.enterOuterAlt(localctx, 2)
                self.state = 75
                self.lambdef()

            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LambdefContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SignalFlowV2Parser.LambdefContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LAMBDA(self):
            return self.getToken(SignalFlowV2Parser.LAMBDA, 0)

        def ID(self):
            return self.getToken(SignalFlowV2Parser.ID, 0)

        def COLON(self):
            return self.getToken(SignalFlowV2Parser.COLON, 0)

        def test(self):
            return self.getTypedRuleContext(SignalFlowV2Parser.TestContext,0)


        def getRuleIndex(self):
            return SignalFlowV2Parser.RULE_lambdef

        def enterRule(self, listener):
            if hasattr(listener, "enterLambdef"):
                listener.enterLambdef(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitLambdef"):
                listener.exitLambdef(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitLambdef"):
                return visitor.visitLambdef(self)
            else:
                return visitor.visitChildren(self)




    def lambdef(self):

        localctx = SignalFlowV2Parser.LambdefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_lambdef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 78
            self.match(SignalFlowV2Parser.LAMBDA)
            self.state = 79
            self.match(SignalFlowV2Parser.ID)
            self.state = 80
            self.match(SignalFlowV2Parser.COLON)
            self.state = 81
            self.test()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Or_testContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SignalFlowV2Parser.Or_testContext, self).__init__(parent, invokingState)
            self.parser = parser

        def and_test(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(SignalFlowV2Parser.And_testContext)
            else:
                return self.getTypedRuleContext(SignalFlowV2Parser.And_testContext,i)


        def OR(self, i=None):
            if i is None:
                return self.getTokens(SignalFlowV2Parser.OR)
            else:
                return self.getToken(SignalFlowV2Parser.OR, i)

        def getRuleIndex(self):
            return SignalFlowV2Parser.RULE_or_test

        def enterRule(self, listener):
            if hasattr(listener, "enterOr_test"):
                listener.enterOr_test(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitOr_test"):
                listener.exitOr_test(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitOr_test"):
                return visitor.visitOr_test(self)
            else:
                return visitor.visitChildren(self)




    def or_test(self):

        localctx = SignalFlowV2Parser.Or_testContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_or_test)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 83
            self.and_test()
            self.state = 88
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SignalFlowV2Parser.OR:
                self.state = 84
                self.match(SignalFlowV2Parser.OR)
                self.state = 85
                self.and_test()
                self.state = 90
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class And_testContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SignalFlowV2Parser.And_testContext, self).__init__(parent, invokingState)
            self.parser = parser

        def not_test(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(SignalFlowV2Parser.Not_testContext)
            else:
                return self.getTypedRuleContext(SignalFlowV2Parser.Not_testContext,i)


        def AND(self, i=None):
            if i is None:
                return self.getTokens(SignalFlowV2Parser.AND)
            else:
                return self.getToken(SignalFlowV2Parser.AND, i)

        def getRuleIndex(self):
            return SignalFlowV2Parser.RULE_and_test

        def enterRule(self, listener):
            if hasattr(listener, "enterAnd_test"):
                listener.enterAnd_test(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitAnd_test"):
                listener.exitAnd_test(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitAnd_test"):
                return visitor.visitAnd_test(self)
            else:
                return visitor.visitChildren(self)




    def and_test(self):

        localctx = SignalFlowV2Parser.And_testContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_and_test)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 91
            self.not_test()
            self.state = 96
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SignalFlowV2Parser.AND:
                self.state = 92
                self.match(SignalFlowV2Parser.AND)
                self.state = 93
                self.not_test()
                self.state = 98
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Not_testContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SignalFlowV2Parser.Not_testContext, self).__init__(parent, invokingState)
            self.parser = parser

        def NOT(self):
            return self.getToken(SignalFlowV2Parser.NOT, 0)

        def not_test(self):
            return self.getTypedRuleContext(SignalFlowV2Parser.Not_testContext,0)


        def comparison(self):
            return self.getTypedRuleContext(SignalFlowV2Parser.ComparisonContext,0)


        def getRuleIndex(self):
            return SignalFlowV2Parser.RULE_not_test

        def enterRule(self, listener):
            if hasattr(listener, "enterNot_test"):
                listener.enterNot_test(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitNot_test"):
                listener.exitNot_test(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitNot_test"):
                return visitor.visitNot_test(self)
            else:
                return visitor.visitChildren(self)




    def not_test(self):

        localctx = SignalFlowV2Parser.Not_testContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_not_test)
        try:
            self.state = 102
            token = self._input.LA(1)
            if token in [SignalFlowV2Parser.NOT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 99
                self.match(SignalFlowV2Parser.NOT)
                self.state = 100
                self.not_test()

            elif token in [SignalFlowV2Parser.NONE, SignalFlowV2Parser.TRUE, SignalFlowV2Parser.FALSE, SignalFlowV2Parser.INT, SignalFlowV2Parser.FLOAT, SignalFlowV2Parser.STRING, SignalFlowV2Parser.ID, SignalFlowV2Parser.LPAREN, SignalFlowV2Parser.LSQUARE, SignalFlowV2Parser.PLUS, SignalFlowV2Parser.MINUS]:
                self.enterOuterAlt(localctx, 2)
                self.state = 101
                self.comparison()

            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ComparisonContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SignalFlowV2Parser.ComparisonContext, self).__init__(parent, invokingState)
            self.parser = parser

        def expr(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(SignalFlowV2Parser.ExprContext)
            else:
                return self.getTypedRuleContext(SignalFlowV2Parser.ExprContext,i)


        def LT(self, i=None):
            if i is None:
                return self.getTokens(SignalFlowV2Parser.LT)
            else:
                return self.getToken(SignalFlowV2Parser.LT, i)

        def LE(self, i=None):
            if i is None:
                return self.getTokens(SignalFlowV2Parser.LE)
            else:
                return self.getToken(SignalFlowV2Parser.LE, i)

        def EQ(self, i=None):
            if i is None:
                return self.getTokens(SignalFlowV2Parser.EQ)
            else:
                return self.getToken(SignalFlowV2Parser.EQ, i)

        def NE(self, i=None):
            if i is None:
                return self.getTokens(SignalFlowV2Parser.NE)
            else:
                return self.getToken(SignalFlowV2Parser.NE, i)

        def GT(self, i=None):
            if i is None:
                return self.getTokens(SignalFlowV2Parser.GT)
            else:
                return self.getToken(SignalFlowV2Parser.GT, i)

        def GE(self, i=None):
            if i is None:
                return self.getTokens(SignalFlowV2Parser.GE)
            else:
                return self.getToken(SignalFlowV2Parser.GE, i)

        def getRuleIndex(self):
            return SignalFlowV2Parser.RULE_comparison

        def enterRule(self, listener):
            if hasattr(listener, "enterComparison"):
                listener.enterComparison(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitComparison"):
                listener.exitComparison(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitComparison"):
                return visitor.visitComparison(self)
            else:
                return visitor.visitChildren(self)




    def comparison(self):

        localctx = SignalFlowV2Parser.ComparisonContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_comparison)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 104
            self.expr()
            self.state = 109
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SignalFlowV2Parser.LE) | (1 << SignalFlowV2Parser.GE) | (1 << SignalFlowV2Parser.EQ) | (1 << SignalFlowV2Parser.NE) | (1 << SignalFlowV2Parser.LT) | (1 << SignalFlowV2Parser.GT))) != 0):
                self.state = 105
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SignalFlowV2Parser.LE) | (1 << SignalFlowV2Parser.GE) | (1 << SignalFlowV2Parser.EQ) | (1 << SignalFlowV2Parser.NE) | (1 << SignalFlowV2Parser.LT) | (1 << SignalFlowV2Parser.GT))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self.consume()
                self.state = 106
                self.expr()
                self.state = 111
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExprContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SignalFlowV2Parser.ExprContext, self).__init__(parent, invokingState)
            self.parser = parser

        def term(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(SignalFlowV2Parser.TermContext)
            else:
                return self.getTypedRuleContext(SignalFlowV2Parser.TermContext,i)


        def PLUS(self, i=None):
            if i is None:
                return self.getTokens(SignalFlowV2Parser.PLUS)
            else:
                return self.getToken(SignalFlowV2Parser.PLUS, i)

        def MINUS(self, i=None):
            if i is None:
                return self.getTokens(SignalFlowV2Parser.MINUS)
            else:
                return self.getToken(SignalFlowV2Parser.MINUS, i)

        def getRuleIndex(self):
            return SignalFlowV2Parser.RULE_expr

        def enterRule(self, listener):
            if hasattr(listener, "enterExpr"):
                listener.enterExpr(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitExpr"):
                listener.exitExpr(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitExpr"):
                return visitor.visitExpr(self)
            else:
                return visitor.visitChildren(self)




    def expr(self):

        localctx = SignalFlowV2Parser.ExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 112
            self.term()
            self.state = 117
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SignalFlowV2Parser.PLUS or _la==SignalFlowV2Parser.MINUS:
                self.state = 113
                _la = self._input.LA(1)
                if not(_la==SignalFlowV2Parser.PLUS or _la==SignalFlowV2Parser.MINUS):
                    self._errHandler.recoverInline(self)
                else:
                    self.consume()
                self.state = 114
                self.term()
                self.state = 119
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TermContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SignalFlowV2Parser.TermContext, self).__init__(parent, invokingState)
            self.parser = parser

        def factor(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(SignalFlowV2Parser.FactorContext)
            else:
                return self.getTypedRuleContext(SignalFlowV2Parser.FactorContext,i)


        def MUL(self, i=None):
            if i is None:
                return self.getTokens(SignalFlowV2Parser.MUL)
            else:
                return self.getToken(SignalFlowV2Parser.MUL, i)

        def DIV(self, i=None):
            if i is None:
                return self.getTokens(SignalFlowV2Parser.DIV)
            else:
                return self.getToken(SignalFlowV2Parser.DIV, i)

        def getRuleIndex(self):
            return SignalFlowV2Parser.RULE_term

        def enterRule(self, listener):
            if hasattr(listener, "enterTerm"):
                listener.enterTerm(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitTerm"):
                listener.exitTerm(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitTerm"):
                return visitor.visitTerm(self)
            else:
                return visitor.visitChildren(self)




    def term(self):

        localctx = SignalFlowV2Parser.TermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_term)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 120
            self.factor()
            self.state = 125
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SignalFlowV2Parser.MUL or _la==SignalFlowV2Parser.DIV:
                self.state = 121
                _la = self._input.LA(1)
                if not(_la==SignalFlowV2Parser.MUL or _la==SignalFlowV2Parser.DIV):
                    self._errHandler.recoverInline(self)
                else:
                    self.consume()
                self.state = 122
                self.factor()
                self.state = 127
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FactorContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SignalFlowV2Parser.FactorContext, self).__init__(parent, invokingState)
            self.parser = parser

        def factor(self):
            return self.getTypedRuleContext(SignalFlowV2Parser.FactorContext,0)


        def PLUS(self):
            return self.getToken(SignalFlowV2Parser.PLUS, 0)

        def MINUS(self):
            return self.getToken(SignalFlowV2Parser.MINUS, 0)

        def power(self):
            return self.getTypedRuleContext(SignalFlowV2Parser.PowerContext,0)


        def getRuleIndex(self):
            return SignalFlowV2Parser.RULE_factor

        def enterRule(self, listener):
            if hasattr(listener, "enterFactor"):
                listener.enterFactor(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitFactor"):
                listener.exitFactor(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitFactor"):
                return visitor.visitFactor(self)
            else:
                return visitor.visitChildren(self)




    def factor(self):

        localctx = SignalFlowV2Parser.FactorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_factor)
        self._la = 0 # Token type
        try:
            self.state = 131
            token = self._input.LA(1)
            if token in [SignalFlowV2Parser.PLUS, SignalFlowV2Parser.MINUS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 128
                _la = self._input.LA(1)
                if not(_la==SignalFlowV2Parser.PLUS or _la==SignalFlowV2Parser.MINUS):
                    self._errHandler.recoverInline(self)
                else:
                    self.consume()
                self.state = 129
                self.factor()

            elif token in [SignalFlowV2Parser.NONE, SignalFlowV2Parser.TRUE, SignalFlowV2Parser.FALSE, SignalFlowV2Parser.INT, SignalFlowV2Parser.FLOAT, SignalFlowV2Parser.STRING, SignalFlowV2Parser.ID, SignalFlowV2Parser.LPAREN, SignalFlowV2Parser.LSQUARE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 130
                self.power()

            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PowerContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SignalFlowV2Parser.PowerContext, self).__init__(parent, invokingState)
            self.parser = parser

        def atom_expr(self):
            return self.getTypedRuleContext(SignalFlowV2Parser.Atom_exprContext,0)


        def POW(self):
            return self.getToken(SignalFlowV2Parser.POW, 0)

        def factor(self):
            return self.getTypedRuleContext(SignalFlowV2Parser.FactorContext,0)


        def getRuleIndex(self):
            return SignalFlowV2Parser.RULE_power

        def enterRule(self, listener):
            if hasattr(listener, "enterPower"):
                listener.enterPower(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitPower"):
                listener.exitPower(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitPower"):
                return visitor.visitPower(self)
            else:
                return visitor.visitChildren(self)




    def power(self):

        localctx = SignalFlowV2Parser.PowerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_power)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 133
            self.atom_expr()
            self.state = 136
            _la = self._input.LA(1)
            if _la==SignalFlowV2Parser.POW:
                self.state = 134
                self.match(SignalFlowV2Parser.POW)
                self.state = 135
                self.factor()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Atom_exprContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SignalFlowV2Parser.Atom_exprContext, self).__init__(parent, invokingState)
            self.parser = parser

        def atom(self):
            return self.getTypedRuleContext(SignalFlowV2Parser.AtomContext,0)


        def trailer(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(SignalFlowV2Parser.TrailerContext)
            else:
                return self.getTypedRuleContext(SignalFlowV2Parser.TrailerContext,i)


        def getRuleIndex(self):
            return SignalFlowV2Parser.RULE_atom_expr

        def enterRule(self, listener):
            if hasattr(listener, "enterAtom_expr"):
                listener.enterAtom_expr(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitAtom_expr"):
                listener.exitAtom_expr(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitAtom_expr"):
                return visitor.visitAtom_expr(self)
            else:
                return visitor.visitChildren(self)




    def atom_expr(self):

        localctx = SignalFlowV2Parser.Atom_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_atom_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 138
            self.atom()
            self.state = 142
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SignalFlowV2Parser.LPAREN or _la==SignalFlowV2Parser.DOT:
                self.state = 139
                self.trailer()
                self.state = 144
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AtomContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SignalFlowV2Parser.AtomContext, self).__init__(parent, invokingState)
            self.parser = parser

        def list_value(self):
            return self.getTypedRuleContext(SignalFlowV2Parser.List_valueContext,0)


        def LPAREN(self):
            return self.getToken(SignalFlowV2Parser.LPAREN, 0)

        def test(self):
            return self.getTypedRuleContext(SignalFlowV2Parser.TestContext,0)


        def RPAREN(self):
            return self.getToken(SignalFlowV2Parser.RPAREN, 0)

        def ID(self):
            return self.getToken(SignalFlowV2Parser.ID, 0)

        def INT(self):
            return self.getToken(SignalFlowV2Parser.INT, 0)

        def FLOAT(self):
            return self.getToken(SignalFlowV2Parser.FLOAT, 0)

        def STRING(self, i=None):
            if i is None:
                return self.getTokens(SignalFlowV2Parser.STRING)
            else:
                return self.getToken(SignalFlowV2Parser.STRING, i)

        def NONE(self):
            return self.getToken(SignalFlowV2Parser.NONE, 0)

        def TRUE(self):
            return self.getToken(SignalFlowV2Parser.TRUE, 0)

        def FALSE(self):
            return self.getToken(SignalFlowV2Parser.FALSE, 0)

        def getRuleIndex(self):
            return SignalFlowV2Parser.RULE_atom

        def enterRule(self, listener):
            if hasattr(listener, "enterAtom"):
                listener.enterAtom(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitAtom"):
                listener.exitAtom(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitAtom"):
                return visitor.visitAtom(self)
            else:
                return visitor.visitChildren(self)




    def atom(self):

        localctx = SignalFlowV2Parser.AtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_atom)
        self._la = 0 # Token type
        try:
            self.state = 161
            token = self._input.LA(1)
            if token in [SignalFlowV2Parser.LSQUARE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 145
                self.list_value()

            elif token in [SignalFlowV2Parser.LPAREN]:
                self.enterOuterAlt(localctx, 2)
                self.state = 146
                self.match(SignalFlowV2Parser.LPAREN)
                self.state = 147
                self.test()
                self.state = 148
                self.match(SignalFlowV2Parser.RPAREN)

            elif token in [SignalFlowV2Parser.ID]:
                self.enterOuterAlt(localctx, 3)
                self.state = 150
                self.match(SignalFlowV2Parser.ID)

            elif token in [SignalFlowV2Parser.INT]:
                self.enterOuterAlt(localctx, 4)
                self.state = 151
                self.match(SignalFlowV2Parser.INT)

            elif token in [SignalFlowV2Parser.FLOAT]:
                self.enterOuterAlt(localctx, 5)
                self.state = 152
                self.match(SignalFlowV2Parser.FLOAT)

            elif token in [SignalFlowV2Parser.STRING]:
                self.enterOuterAlt(localctx, 6)
                self.state = 154 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 153
                    self.match(SignalFlowV2Parser.STRING)
                    self.state = 156 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==SignalFlowV2Parser.STRING):
                        break


            elif token in [SignalFlowV2Parser.NONE]:
                self.enterOuterAlt(localctx, 7)
                self.state = 158
                self.match(SignalFlowV2Parser.NONE)

            elif token in [SignalFlowV2Parser.TRUE]:
                self.enterOuterAlt(localctx, 8)
                self.state = 159
                self.match(SignalFlowV2Parser.TRUE)

            elif token in [SignalFlowV2Parser.FALSE]:
                self.enterOuterAlt(localctx, 9)
                self.state = 160
                self.match(SignalFlowV2Parser.FALSE)

            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class List_valueContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SignalFlowV2Parser.List_valueContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LSQUARE(self):
            return self.getToken(SignalFlowV2Parser.LSQUARE, 0)

        def RSQUARE(self):
            return self.getToken(SignalFlowV2Parser.RSQUARE, 0)

        def test(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(SignalFlowV2Parser.TestContext)
            else:
                return self.getTypedRuleContext(SignalFlowV2Parser.TestContext,i)


        def COMMA(self, i=None):
            if i is None:
                return self.getTokens(SignalFlowV2Parser.COMMA)
            else:
                return self.getToken(SignalFlowV2Parser.COMMA, i)

        def getRuleIndex(self):
            return SignalFlowV2Parser.RULE_list_value

        def enterRule(self, listener):
            if hasattr(listener, "enterList_value"):
                listener.enterList_value(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitList_value"):
                listener.exitList_value(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitList_value"):
                return visitor.visitList_value(self)
            else:
                return visitor.visitChildren(self)




    def list_value(self):

        localctx = SignalFlowV2Parser.List_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_list_value)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 163
            self.match(SignalFlowV2Parser.LSQUARE)
            self.state = 172
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SignalFlowV2Parser.LAMBDA) | (1 << SignalFlowV2Parser.NONE) | (1 << SignalFlowV2Parser.TRUE) | (1 << SignalFlowV2Parser.FALSE) | (1 << SignalFlowV2Parser.INT) | (1 << SignalFlowV2Parser.FLOAT) | (1 << SignalFlowV2Parser.STRING) | (1 << SignalFlowV2Parser.NOT) | (1 << SignalFlowV2Parser.ID) | (1 << SignalFlowV2Parser.LPAREN) | (1 << SignalFlowV2Parser.LSQUARE) | (1 << SignalFlowV2Parser.PLUS) | (1 << SignalFlowV2Parser.MINUS))) != 0):
                self.state = 164
                self.test()
                self.state = 169
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==SignalFlowV2Parser.COMMA:
                    self.state = 165
                    self.match(SignalFlowV2Parser.COMMA)
                    self.state = 166
                    self.test()
                    self.state = 171
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 174
            self.match(SignalFlowV2Parser.RSQUARE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TrailerContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SignalFlowV2Parser.TrailerContext, self).__init__(parent, invokingState)
            self.parser = parser

        def LPAREN(self):
            return self.getToken(SignalFlowV2Parser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(SignalFlowV2Parser.RPAREN, 0)

        def actual_args(self):
            return self.getTypedRuleContext(SignalFlowV2Parser.Actual_argsContext,0)


        def DOT(self):
            return self.getToken(SignalFlowV2Parser.DOT, 0)

        def ID(self):
            return self.getToken(SignalFlowV2Parser.ID, 0)

        def getRuleIndex(self):
            return SignalFlowV2Parser.RULE_trailer

        def enterRule(self, listener):
            if hasattr(listener, "enterTrailer"):
                listener.enterTrailer(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitTrailer"):
                listener.exitTrailer(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitTrailer"):
                return visitor.visitTrailer(self)
            else:
                return visitor.visitChildren(self)




    def trailer(self):

        localctx = SignalFlowV2Parser.TrailerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_trailer)
        self._la = 0 # Token type
        try:
            self.state = 183
            token = self._input.LA(1)
            if token in [SignalFlowV2Parser.LPAREN]:
                self.enterOuterAlt(localctx, 1)
                self.state = 176
                self.match(SignalFlowV2Parser.LPAREN)
                self.state = 178
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << SignalFlowV2Parser.LAMBDA) | (1 << SignalFlowV2Parser.NONE) | (1 << SignalFlowV2Parser.TRUE) | (1 << SignalFlowV2Parser.FALSE) | (1 << SignalFlowV2Parser.INT) | (1 << SignalFlowV2Parser.FLOAT) | (1 << SignalFlowV2Parser.STRING) | (1 << SignalFlowV2Parser.NOT) | (1 << SignalFlowV2Parser.ID) | (1 << SignalFlowV2Parser.LPAREN) | (1 << SignalFlowV2Parser.LSQUARE) | (1 << SignalFlowV2Parser.PLUS) | (1 << SignalFlowV2Parser.MINUS))) != 0):
                    self.state = 177
                    self.actual_args()


                self.state = 180
                self.match(SignalFlowV2Parser.RPAREN)

            elif token in [SignalFlowV2Parser.DOT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 181
                self.match(SignalFlowV2Parser.DOT)
                self.state = 182
                self.match(SignalFlowV2Parser.ID)

            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Actual_argsContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SignalFlowV2Parser.Actual_argsContext, self).__init__(parent, invokingState)
            self.parser = parser

        def argument(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(SignalFlowV2Parser.ArgumentContext)
            else:
                return self.getTypedRuleContext(SignalFlowV2Parser.ArgumentContext,i)


        def COMMA(self, i=None):
            if i is None:
                return self.getTokens(SignalFlowV2Parser.COMMA)
            else:
                return self.getToken(SignalFlowV2Parser.COMMA, i)

        def getRuleIndex(self):
            return SignalFlowV2Parser.RULE_actual_args

        def enterRule(self, listener):
            if hasattr(listener, "enterActual_args"):
                listener.enterActual_args(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitActual_args"):
                listener.exitActual_args(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitActual_args"):
                return visitor.visitActual_args(self)
            else:
                return visitor.visitChildren(self)




    def actual_args(self):

        localctx = SignalFlowV2Parser.Actual_argsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_actual_args)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 185
            self.argument()
            self.state = 190
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SignalFlowV2Parser.COMMA:
                self.state = 186
                self.match(SignalFlowV2Parser.COMMA)
                self.state = 187
                self.argument()
                self.state = 192
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ArgumentContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(SignalFlowV2Parser.ArgumentContext, self).__init__(parent, invokingState)
            self.parser = parser

        def test(self):
            return self.getTypedRuleContext(SignalFlowV2Parser.TestContext,0)


        def ID(self):
            return self.getToken(SignalFlowV2Parser.ID, 0)

        def BINDING(self):
            return self.getToken(SignalFlowV2Parser.BINDING, 0)

        def getRuleIndex(self):
            return SignalFlowV2Parser.RULE_argument

        def enterRule(self, listener):
            if hasattr(listener, "enterArgument"):
                listener.enterArgument(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitArgument"):
                listener.exitArgument(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitArgument"):
                return visitor.visitArgument(self)
            else:
                return visitor.visitChildren(self)




    def argument(self):

        localctx = SignalFlowV2Parser.ArgumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_argument)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 195
            la_ = self._interp.adaptivePredict(self._input,23,self._ctx)
            if la_ == 1:
                self.state = 193
                self.match(SignalFlowV2Parser.ID)
                self.state = 194
                self.match(SignalFlowV2Parser.BINDING)


            self.state = 197
            self.test()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





