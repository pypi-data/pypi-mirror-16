

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Using custom Element classes in lxml &mdash; lxml v2.3 - Processing XML and HTML with Python</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '2.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="lxml v2.3 - Processing XML and HTML with Python" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="main.html">lxml v2.3 - Processing XML and HTML with Python</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="using-custom-element-classes-in-lxml">
<h1><a class="toc-backref" href="#id2">Using custom Element classes in lxml</a><a class="headerlink" href="#using-custom-element-classes-in-lxml" title="Permalink to this headline">¶</a></h1>
<p>lxml has very sophisticated support for custom Element classes.  You
can provide your own classes for Elements and have lxml use them by
default for all elements generated by a specific parser, only for a
specific tag name in a specific namespace or even for an exact element
at a specific position in the tree.</p>
<p>Custom Elements must inherit from the <tt class="docutils literal"><span class="pre">lxml.etree.ElementBase</span></tt> class, which
provides the Element interface for subclasses:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">lxml</span> <span class="kn">import</span> <span class="n">etree</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">honk</span><span class="p">(</span><span class="n">etree</span><span class="o">.</span><span class="n">ElementBase</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">def</span> <span class="nf">honking</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;honking&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;true&#39;</span>
<span class="gp">... </span>   <span class="n">honking</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">honking</span><span class="p">)</span>
</pre></div>
</div>
<p>This defines a new Element class <tt class="docutils literal"><span class="pre">honk</span></tt> with a property <tt class="docutils literal"><span class="pre">honking</span></tt>.</p>
<p>The following document describes how you can make lxml.etree use these
custom Element classes.</p>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#using-custom-element-classes-in-lxml" id="id2">Using custom Element classes in lxml</a><ul>
<li><a class="reference internal" href="#background-on-element-proxies" id="id3">Background on Element proxies</a></li>
<li><a class="reference internal" href="#element-initialization" id="id4">Element initialization</a></li>
<li><a class="reference internal" href="#setting-up-a-class-lookup-scheme" id="id5">Setting up a class lookup scheme</a><ul>
<li><a class="reference internal" href="#default-class-lookup" id="id6">Default class lookup</a></li>
<li><a class="reference internal" href="#namespace-class-lookup" id="id7">Namespace class lookup</a></li>
<li><a class="reference internal" href="#attribute-based-lookup" id="id8">Attribute based lookup</a></li>
<li><a class="reference internal" href="#custom-element-class-lookup" id="id9">Custom element class lookup</a></li>
<li><a class="reference internal" href="#tree-based-element-class-lookup-in-python" id="id10">Tree based element class lookup in Python</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generating-xml-with-custom-classes" id="id11">Generating XML with custom classes</a></li>
<li><a class="reference internal" href="#id1" id="id12">Implementing namespaces</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="background-on-element-proxies">
<h2><a class="toc-backref" href="#id3">Background on Element proxies</a><a class="headerlink" href="#background-on-element-proxies" title="Permalink to this headline">¶</a></h2>
<p>Being based on libxml2, lxml.etree holds the entire XML tree in a C
structure.  To communicate with Python code, it creates Python proxy
objects for the XML elements on demand.</p>
<blockquote>
<div><img alt="proxies.png" src="proxies.png" />
</div></blockquote>
<p>The mapping between C elements and Python Element classes is
completely configurable.  When you ask lxml.etree for an Element by
using its API, it will instantiate your classes for you.  All you have
to do is tell lxml which class to use for which kind of Element.  This
is done through a class lookup scheme, as described in the sections
below.</p>
</div>
<div class="section" id="element-initialization">
<h2><a class="toc-backref" href="#id4">Element initialization</a><a class="headerlink" href="#element-initialization" title="Permalink to this headline">¶</a></h2>
<p>There is one thing to know up front.  Element classes <em>must not</em> have
an <tt class="docutils literal"><span class="pre">__init___</span></tt> or <tt class="docutils literal"><span class="pre">__new__</span></tt> method.  There should not be any
internal state either, except for the data stored in the underlying
XML tree.  Element instances are created and garbage collected at
need, so there is normally no way to predict when and how often a
proxy is created for them.  Even worse, when the <tt class="docutils literal"><span class="pre">__init__</span></tt> method
is called, the object is not even initialized yet to represent the XML
tag, so there is not much use in providing an <tt class="docutils literal"><span class="pre">__init__</span></tt> method in
subclasses.</p>
<p>Most use cases will not require any class initialisation or proxy
state, so you can content yourself with skipping to the next section
for now.  However, if you really need to set up your element class on
instantiation, or need a way to persistently store state in the proxy
instances instead of the XML tree, here is a way to do so.</p>
<p>There is one important guarantee regarding Element proxies.  Once a
proxy has been instantiated, it will keep alive as long as there is a
Python reference to it, and any access to the XML element in the tree
will return this very instance.  Therefore, if you need to store local
state in a custom Element class (which is generally discouraged), you
can do so by keeping the Elements in a tree alive.  If the tree
doesn&#8217;t change, you can simply do this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">proxy_cache</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">iter</span><span class="p">())</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">proxy_cache</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">iter</span><span class="p">())</span>
</pre></div>
</div>
<p>or use any other suitable container.  Note that you have to keep this
cache manually up to date if the tree changes, which can get tricky in
cases.</p>
<p>For proxy initialisation, ElementBase classes have an <tt class="docutils literal"><span class="pre">_init()</span></tt>
method that can be overridden, as oppose to the normal <tt class="docutils literal"><span class="pre">__init__()</span></tt>
method.  It can be used to modify the XML tree, e.g. to construct
special children or verify and update attributes.</p>
<p>The semantics of <tt class="docutils literal"><span class="pre">_init()</span></tt> are as follows:</p>
<ul class="simple">
<li>It is called once on Element class instantiation time.  That is,
when a Python representation of the element is created by lxml.  At
that time, the element object is completely initialized to represent
a specific XML element within the tree.</li>
<li>The method has complete access to the XML tree.  Modifications can be done
in exactly the same way as anywhere else in the program.</li>
<li>Python representations of elements may be created multiple times during the
lifetime of an XML element in the underlying C tree.  The <tt class="docutils literal"><span class="pre">_init()</span></tt> code
provided by subclasses must take special care by itself that multiple
executions either are harmless or that they are prevented by some kind of
flag in the XML tree.  The latter can be achieved by modifying an attribute
value or by removing or adding a specific child node and then verifying this
before running through the init process.</li>
<li>Any exceptions raised in <tt class="docutils literal"><span class="pre">_init()</span></tt> will be propagated throught the API
call that lead to the creation of the Element.  So be careful with the code
you write here as its exceptions may turn up in various unexpected places.</li>
</ul>
</div>
<div class="section" id="setting-up-a-class-lookup-scheme">
<h2><a class="toc-backref" href="#id5">Setting up a class lookup scheme</a><a class="headerlink" href="#setting-up-a-class-lookup-scheme" title="Permalink to this headline">¶</a></h2>
<p>The first thing to do when deploying custom element classes is to register a
class lookup scheme on a parser.  lxml.etree provides quite a number of
different schemes that also support class lookup based on namespaces or
attribute values.  Most lookups support fallback chaining, which allows the
next lookup mechanism to take over when the previous one fails to find a
class.</p>
<p>For example, setting the <tt class="docutils literal"><span class="pre">honk</span></tt> Element as a default element class
for a parser works as follows:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">parser_lookup</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">ElementDefaultClassLookup</span><span class="p">(</span><span class="n">element</span><span class="o">=</span><span class="n">honk</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">XMLParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">set_element_class_lookup</span><span class="p">(</span><span class="n">parser_lookup</span><span class="p">)</span>
</pre></div>
</div>
<p>There is one drawback of the parser based scheme: the <tt class="docutils literal"><span class="pre">Element()</span></tt> factory
does not know about your specialised parser and creates a new document that
deploys the default parser:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">el</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="s">&quot;root&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">honk</span><span class="p">))</span>
<span class="go">False</span>
</pre></div>
</div>
<p>You should therefore avoid using this factory function in code that
uses custom classes.  The <tt class="docutils literal"><span class="pre">makeelement()</span></tt> method of parsers provides
a simple replacement:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">el</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">makeelement</span><span class="p">(</span><span class="s">&quot;root&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">honk</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If you use a parser at the module level, you can easily redirect a module
level <tt class="docutils literal"><span class="pre">Element()</span></tt> factory to the parser method by adding code like this:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">module_level_parser</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">XMLParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Element</span> <span class="o">=</span> <span class="n">module_level_parser</span><span class="o">.</span><span class="n">makeelement</span>
</pre></div>
</div>
<p>While the <tt class="docutils literal"><span class="pre">XML()</span></tt> and <tt class="docutils literal"><span class="pre">HTML()</span></tt> factories also depend on the default
parser, you can pass them a different parser as second argument:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">element</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">XML</span><span class="p">(</span><span class="s">&quot;&lt;test/&gt;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">honk</span><span class="p">))</span>
<span class="go">False</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">element</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">XML</span><span class="p">(</span><span class="s">&quot;&lt;test/&gt;&quot;</span><span class="p">,</span> <span class="n">parser</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">honk</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Whenever you create a document with a parser, it will inherit the lookup
scheme and all subsequent element instantiations for this document will use
it:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">element</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="s">&quot;&lt;test/&gt;&quot;</span><span class="p">,</span> <span class="n">parser</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">honk</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">el</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s">&quot;subel&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">honk</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>For testing code in the Python interpreter and for small projects, you
may also consider setting a lookup scheme on the default parser.  To
avoid interfering with other modules, however, it is usually a better
idea to use a dedicated parser for each module (or a parser pool when
using threads) and then register the required lookup scheme only for
this parser.</p>
<div class="section" id="default-class-lookup">
<h3><a class="toc-backref" href="#id6">Default class lookup</a><a class="headerlink" href="#default-class-lookup" title="Permalink to this headline">¶</a></h3>
<p>This is the most simple lookup mechanism.  It always returns the default
element class.  Consequently, no further fallbacks are supported, but this
scheme is a nice fallback for other custom lookup mechanisms.</p>
<p>Usage:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">lookup</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">ElementDefaultClassLookup</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">XMLParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">set_element_class_lookup</span><span class="p">(</span><span class="n">lookup</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that the default for new parsers is to use the global fallback, which is
also the default lookup (if not configured otherwise).</p>
<p>To change the default element implementation, you can pass your new class to
the constructor.  While it accepts classes for <tt class="docutils literal"><span class="pre">element</span></tt>, <tt class="docutils literal"><span class="pre">comment</span></tt> and
<tt class="docutils literal"><span class="pre">pi</span></tt> nodes, most use cases will only override the element class:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">el</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">makeelement</span><span class="p">(</span><span class="s">&quot;myelement&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">honk</span><span class="p">))</span>
<span class="go">False</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">lookup</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">ElementDefaultClassLookup</span><span class="p">(</span><span class="n">element</span><span class="o">=</span><span class="n">honk</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">set_element_class_lookup</span><span class="p">(</span><span class="n">lookup</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">el</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">makeelement</span><span class="p">(</span><span class="s">&quot;myelement&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">honk</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">el</span><span class="o">.</span><span class="n">honking</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">el</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">makeelement</span><span class="p">(</span><span class="s">&quot;myelement&quot;</span><span class="p">,</span> <span class="n">honking</span><span class="o">=</span><span class="s">&#39;true&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
<span class="go">b&#39;&lt;myelement honking=&quot;true&quot;/&gt;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">el</span><span class="o">.</span><span class="n">honking</span>
<span class="go">True</span>
</pre></div>
</div>
</div>
<div class="section" id="namespace-class-lookup">
<h3><a class="toc-backref" href="#id7">Namespace class lookup</a><a class="headerlink" href="#namespace-class-lookup" title="Permalink to this headline">¶</a></h3>
<p>This is an advanced lookup mechanism that supports namespace/tag-name specific
element classes.  You can select it by calling:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">lookup</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">ElementNamespaceClassLookup</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">XMLParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">set_element_class_lookup</span><span class="p">(</span><span class="n">lookup</span><span class="p">)</span>
</pre></div>
</div>
<p>See the separate section on <a class="reference external" href="#implementing-namespaces">implementing namespaces</a> below to learn how to
make use of it.</p>
<p>This scheme supports a fallback mechanism that is used in the case where the
namespace is not found or no class was registered for the element name.
Normally, the default class lookup is used here.  To change it, pass the
desired fallback lookup scheme to the constructor:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fallback</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">ElementDefaultClassLookup</span><span class="p">(</span><span class="n">element</span><span class="o">=</span><span class="n">honk</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lookup</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">ElementNamespaceClassLookup</span><span class="p">(</span><span class="n">fallback</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">set_element_class_lookup</span><span class="p">(</span><span class="n">lookup</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="attribute-based-lookup">
<h3><a class="toc-backref" href="#id8">Attribute based lookup</a><a class="headerlink" href="#attribute-based-lookup" title="Permalink to this headline">¶</a></h3>
<p>This scheme uses a mapping from attribute values to classes.  An attribute
name is set at initialisation time and is then used to find the corresponding
value in a dictionary.  It is set up as follows:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">id_class_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;1234&#39;</span> <span class="p">:</span> <span class="n">honk</span><span class="p">}</span> <span class="c"># maps attribute values to classes</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">lookup</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">AttributeBasedElementClassLookup</span><span class="p">(</span>
<span class="gp">... </span>                                     <span class="s">&#39;id&#39;</span><span class="p">,</span> <span class="n">id_class_mapping</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">XMLParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">set_element_class_lookup</span><span class="p">(</span><span class="n">lookup</span><span class="p">)</span>
</pre></div>
</div>
<p>This class uses its fallback if the attribute is not found or its value is not
in the mapping.  Normally, the default class lookup is used here.  If you want
to use the namespace lookup, for example, you can use this code:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fallback</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">ElementNamespaceClassLookup</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lookup</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">AttributeBasedElementClassLookup</span><span class="p">(</span>
<span class="gp">... </span>                      <span class="s">&#39;id&#39;</span><span class="p">,</span> <span class="n">id_class_mapping</span><span class="p">,</span> <span class="n">fallback</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">XMLParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">set_element_class_lookup</span><span class="p">(</span><span class="n">lookup</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="custom-element-class-lookup">
<h3><a class="toc-backref" href="#id9">Custom element class lookup</a><a class="headerlink" href="#custom-element-class-lookup" title="Permalink to this headline">¶</a></h3>
<p>This is the most customisable way of finding element classes on a per-element
basis.  It allows you to implement a custom lookup scheme in a subclass:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyLookup</span><span class="p">(</span><span class="n">etree</span><span class="o">.</span><span class="n">CustomElementClassLookup</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_type</span><span class="p">,</span> <span class="n">document</span><span class="p">,</span> <span class="n">namespace</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">honk</span> <span class="c"># be a bit more selective here ...</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">XMLParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">set_element_class_lookup</span><span class="p">(</span><span class="n">MyLookup</span><span class="p">())</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">.lookup()</span></tt> method must return either None (which triggers the
fallback mechanism) or a subclass of <tt class="docutils literal"><span class="pre">lxml.etree.ElementBase</span></tt>.  It
can take any decision it wants based on the node type (one of
&#8220;element&#8221;, &#8220;comment&#8221;, &#8220;PI&#8221;, &#8220;entity&#8221;), the XML document of the
element, or its namespace or tag name.</p>
</div>
<div class="section" id="tree-based-element-class-lookup-in-python">
<h3><a class="toc-backref" href="#id10">Tree based element class lookup in Python</a><a class="headerlink" href="#tree-based-element-class-lookup-in-python" title="Permalink to this headline">¶</a></h3>
<p>Taking more elaborate decisions than allowed by the custom scheme is
difficult to achieve in pure Python, as it results in a
chicken-and-egg problem.  It would require access to the tree - before
the elements in the tree have been instantiated as Python Element
proxies.</p>
<p>Luckily, there is a way to do this.  The <tt class="docutils literal"><span class="pre">PythonElementClassLookup</span></tt>
works similar to the custom lookup scheme:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyLookup</span><span class="p">(</span><span class="n">etree</span><span class="o">.</span><span class="n">PythonElementClassLookup</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">document</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">MyElementClass</span> <span class="c"># defined elsewhere</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">XMLParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">set_element_class_lookup</span><span class="p">(</span><span class="n">MyLookup</span><span class="p">())</span>
</pre></div>
</div>
<p>As before, the first argument to the <tt class="docutils literal"><span class="pre">lookup()</span></tt> method is the opaque
document instance that contains the Element.  The second arguments is a
lightweight Element proxy implementation that is only valid during the lookup.
Do not try to keep a reference to it.  Once the lookup is finished, the proxy
will become invalid.  You will get an <tt class="docutils literal"><span class="pre">AssertionError</span></tt> if you access any of
the properties or methods outside the scope of the lookup call where they were
instantiated.</p>
<p>During the lookup, the element object behaves mostly like a normal Element
instance.  It provides the properties <tt class="docutils literal"><span class="pre">tag</span></tt>, <tt class="docutils literal"><span class="pre">text</span></tt>, <tt class="docutils literal"><span class="pre">tail</span></tt> etc. and
supports indexing, slicing and the <tt class="docutils literal"><span class="pre">getchildren()</span></tt>, <tt class="docutils literal"><span class="pre">getparent()</span></tt>
etc. methods.  It does <em>not</em> support iteration, nor does it support any kind
of modification.  All of its properties are read-only and it cannot be removed
or inserted into other trees.  You can use it as a starting point to freely
traverse the tree and collect any kind of information that its elements
provide.  Once you have taken the decision which class to use for this
element, you can simply return it and have lxml take care of cleaning up the
instantiated proxy classes.</p>
<p>Sidenote: this lookup scheme originally lived in a separate module called
<tt class="docutils literal"><span class="pre">lxml.pyclasslookup</span></tt>.</p>
</div>
</div>
<div class="section" id="generating-xml-with-custom-classes">
<h2><a class="toc-backref" href="#id11">Generating XML with custom classes</a><a class="headerlink" href="#generating-xml-with-custom-classes" title="Permalink to this headline">¶</a></h2>
<p>Up to lxml 2.1, you could not instantiate proxy classes yourself.
Only lxml.etree could do that when creating an object representation
of an existing XML element.  Since lxml 2.2, however, instantiating
this class will simply create a new Element:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">el</span> <span class="o">=</span> <span class="n">honk</span><span class="p">(</span><span class="n">honking</span> <span class="o">=</span> <span class="s">&#39;true&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">el</span><span class="o">.</span><span class="n">tag</span>
<span class="go">&#39;honk&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">el</span><span class="o">.</span><span class="n">honking</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note, however, that the proxy you create here will be garbage
collected just like any other proxy.  You can therefore not count on
lxml.etree using the same class that you instantiated when you access
this Element a second time after letting its reference go.  You should
therefore always use a corresponding class lookup scheme that returns
your Element proxy classes for the elements that they create.  The
<tt class="docutils literal"><span class="pre">ElementNamespaceClassLookup</span></tt> is generally a good match.</p>
<p>You can use custom Element classes to quickly create XML fragments:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">hale</span><span class="p">(</span><span class="n">etree</span><span class="o">.</span><span class="n">ElementBase</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">bopp</span><span class="p">(</span><span class="n">etree</span><span class="o">.</span><span class="n">ElementBase</span><span class="p">):</span> <span class="k">pass</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">el</span> <span class="o">=</span> <span class="n">hale</span><span class="p">(</span> <span class="s">&quot;some &quot;</span><span class="p">,</span> <span class="n">honk</span><span class="p">(</span><span class="n">honking</span> <span class="o">=</span> <span class="s">&#39;true&#39;</span><span class="p">),</span> <span class="n">bopp</span><span class="p">,</span> <span class="s">&quot; text&quot;</span> <span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">etree</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="nb">unicode</span><span class="p">))</span>
<span class="go">&lt;hale&gt;some &lt;honk honking=&quot;true&quot;/&gt;&lt;bopp/&gt; text&lt;/hale&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="id1">
<h2><a class="toc-backref" href="#id12">Implementing namespaces</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>lxml allows you to implement namespaces, in a rather literal sense.  After
setting up the namespace class lookup mechanism as described above, you can
build a new element namespace (or retrieve an existing one) by calling the
<tt class="docutils literal"><span class="pre">get_namespace(uri)</span></tt> method of the lookup:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">lookup</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">ElementNamespaceClassLookup</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">XMLParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span><span class="o">.</span><span class="n">set_element_class_lookup</span><span class="p">(</span><span class="n">lookup</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">namespace</span> <span class="o">=</span> <span class="n">lookup</span><span class="o">.</span><span class="n">get_namespace</span><span class="p">(</span><span class="s">&#39;http://hui.de/honk&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>and then register the new element type with that namespace, say, under the tag
name <tt class="docutils literal"><span class="pre">honk</span></tt>:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">namespace</span><span class="p">[</span><span class="s">&#39;honk&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">honk</span>
</pre></div>
</div>
<p>If you have many Element classes declared in one module, and they are
all named like the elements they create, you can simply use
<tt class="docutils literal"><span class="pre">namespace.update(vars())</span></tt> at the end of your module to declare them
automatically.  The implementation is smart enough to ignore
everything that is not an Element class.</p>
<p>After this, you create and use your XML elements through the normal API of
lxml:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">xml</span> <span class="o">=</span> <span class="s">&#39;&lt;honk xmlns=&quot;http://hui.de/honk&quot; honking=&quot;true&quot;/&gt;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">honk_element</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">XML</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span> <span class="n">parser</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">honk_element</span><span class="o">.</span><span class="n">honking</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The same works when creating elements by hand:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">honk_element</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">makeelement</span><span class="p">(</span><span class="s">&#39;{http://hui.de/honk}honk&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                  <span class="n">honking</span><span class="o">=</span><span class="s">&#39;true&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">honk_element</span><span class="o">.</span><span class="n">honking</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Essentially, what this allows you to do, is to give Elements a custom API
based on their namespace and tag name.</p>
<p>A somewhat related topic are <a class="reference external" href="extensions.html">extension functions</a> which use a similar
mechanism for registering extension functions in XPath and XSLT.</p>
<p>In the setup example above, we associated the <tt class="docutils literal"><span class="pre">honk</span></tt> Element class
only with the &#8216;honk&#8217; element.  If an XML tree contains different
elements in the same namespace, they do not pick up the same
implementation:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">xml</span> <span class="o">=</span> <span class="s">&#39;&lt;honk xmlns=&quot;http://hui.de/honk&quot; honking=&quot;true&quot;&gt;&lt;bla/&gt;&lt;/honk&gt;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">honk_element</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">XML</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span> <span class="n">parser</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">honk_element</span><span class="o">.</span><span class="n">honking</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">honk_element</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">honking</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;lxml.etree._Element&#39; object has no attribute &#39;honking&#39;</span>
</pre></div>
</div>
<p>You can therefore provide one implementation per element name in each
namespace and have lxml select the right one on the fly.  If you want one
element implementation per namespace (ignoring the element name) or prefer
having a common class for most elements except a few, you can specify a
default implementation for an entire namespace by registering that class with
the empty element name (None).</p>
<p>You may consider following an object oriented approach here.  If you build a
class hierarchy of element classes, you can also implement a base class for a
namespace that is used if no specific element class is provided.  Again, you
can just pass None as an element name:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">HonkNSElement</span><span class="p">(</span><span class="n">etree</span><span class="o">.</span><span class="n">ElementBase</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">def</span> <span class="nf">honk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>      <span class="k">return</span> <span class="s">&quot;HONK&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">namespace</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">=</span> <span class="n">HonkNSElement</span> <span class="c"># default Element for namespace</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">HonkElement</span><span class="p">(</span><span class="n">HonkNSElement</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">def</span> <span class="nf">honking</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;honking&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;true&#39;</span>
<span class="gp">... </span>   <span class="n">honking</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">honking</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">namespace</span><span class="p">[</span><span class="s">&#39;honk&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">HonkElement</span> <span class="c"># Element for specific tag</span>
</pre></div>
</div>
<p>Now you can rely on lxml to always return objects of type HonkNSElement or its
subclasses for elements of this namespace:</p>
<div class="highlight-pycon"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">xml</span> <span class="o">=</span> <span class="s">&#39;&lt;honk xmlns=&quot;http://hui.de/honk&quot; honking=&quot;true&quot;&gt;&lt;bla/&gt;&lt;/honk&gt;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">honk_element</span> <span class="o">=</span> <span class="n">etree</span><span class="o">.</span><span class="n">XML</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span> <span class="n">parser</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">honk_element</span><span class="p">))</span>
<span class="go">&lt;class &#39;HonkElement&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">honk_element</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="go">&lt;class &#39;HonkNSElement&#39;&gt;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">honk_element</span><span class="o">.</span><span class="n">honking</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">honk_element</span><span class="o">.</span><span class="n">honk</span><span class="p">())</span>
<span class="go">HONK</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">honk_element</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">honk</span><span class="p">())</span>
<span class="go">HONK</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">honk_element</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">honking</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>: <span class="n">&#39;HonkNSElement&#39; object has no attribute &#39;honking&#39;</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="main.html">
              <img class="logo" src="_static/python-xml-title.png" alt="Logo"/>
            </a></p>
  <h3><a href="main.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Using custom Element classes in lxml</a><ul>
<li><a class="reference internal" href="#background-on-element-proxies">Background on Element proxies</a></li>
<li><a class="reference internal" href="#element-initialization">Element initialization</a></li>
<li><a class="reference internal" href="#setting-up-a-class-lookup-scheme">Setting up a class lookup scheme</a><ul>
<li><a class="reference internal" href="#default-class-lookup">Default class lookup</a></li>
<li><a class="reference internal" href="#namespace-class-lookup">Namespace class lookup</a></li>
<li><a class="reference internal" href="#attribute-based-lookup">Attribute based lookup</a></li>
<li><a class="reference internal" href="#custom-element-class-lookup">Custom element class lookup</a></li>
<li><a class="reference internal" href="#tree-based-element-class-lookup-in-python">Tree based element class lookup in Python</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generating-xml-with-custom-classes">Generating XML with custom classes</a></li>
<li><a class="reference internal" href="#id1">Implementing namespaces</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/element_classes.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li><a href="main.html">lxml v2.3 - Processing XML and HTML with Python</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Stefan Behnel et al..
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>