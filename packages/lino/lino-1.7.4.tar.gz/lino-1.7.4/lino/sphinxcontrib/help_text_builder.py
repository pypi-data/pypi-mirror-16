# -*- coding: UTF-8 -*-
# Copyright 2016 Luc Saffre
# License: BSD (see file COPYING for details)
'''Defines a `Sphinx builder
<http://www.sphinx-doc.org/en/stable/extdev/builderapi.html#sphinx.builders.Builder>`__
which generates a single file named :xfile:`help_texts.py` containing
object descriptions to be installed as the `help_text` attribute of
database fields.

Without help_text builder::

    class MyModel(dd.Model):
        """MyModel is an important example."""

        universe = models.CharField(_("First field"),
            blank=True, max_length=100, help_text=_("""
    The first field contains an optional answer to the
    question about life, the universe and everything.
    """))

With help_text builder::

    class MyModel(dd.Model):
        """MyModel is an important example.

        .. attribute:: universe

            The first field contains an optional answer to the
            question about life, the universe and everything.

        """

        universe = models.CharField(_("First field"),
            blank=True, max_length=100)

Advantages:

- As an application developer you don't need to worry about Python
  syntax consideration when editing your help text

- Same source is used for both the API and the UI.

Note that only the *first* paragraph of the content of every
:rst:dir:`class` and :rst:dir:`attribute` directive is taken as help
text.

Note also that any formatting is removed.


The :xfile:`help_texts.py` file
===============================


.. xfile:: help_texts.py

A file generated by :cmd:`inv bh` which contains a dict of the
form::

    from lino.api import _
    help_texts = {
        'foo': _("A foo is a bar without baz.")
    }


See also :blogref:`20160620`.

:meth:`lino.core.site.Site.install_help_text`
:meth:`lino.core.site.Site.load_help_texts`

Usage
=====

In your :xfile:`conf.py` file, add this line::

    from lino.sphinxcontrib.help_text_builder import setup
    
Run sphinx-build using::

    $ sphinx-build -b help_texts . tmp

Copy the result to the right place, e.g.::

    $ cp tmp/help_texts.py ../lino_voga/lib/voga/


Internals
=========

This builder traverses the doctree in order to find `object
descriptions
<http://www.sphinx-doc.org/en/stable/extdev/nodes.html>`_, i.e.  text
nodes defined by Sphinx and inserted e.g. by the :rst:dir:`class` and
:rst:dir:`attribute` directives (which have been inserted by autodoc
and autosummary).

Example of a class description::

    <desc desctype="class" domain="py" noindex="False" objtype="class">
        <desc_signature class="" first="False" fullname="Plan" ids="..." module="..." names="...">
        <desc_annotation>class </desc_annotation>
            <desc_addname>lino_cosi.lib.invoicing.models.</desc_addname>
            <desc_name>Plan</desc_name>
            <desc_parameterlist>
                <desc_parameter>*args</desc_parameter>
                <desc_parameter>**kwargs</desc_parameter>
            </desc_parameterlist>
        </desc_signature>
        <desc_content>
            <paragraph>Bases: <reference internal="False" reftitle="(in Lino v1.7)" refuri="http://www.lino-framework.org/api/lino.modlib.users.mixins.html#lino.modlib.users.mixins.UserAuthored"><literal classes="xref py py-class">lino.modlib.users.mixins.UserAuthored</literal></reference>
            </paragraph>
            <paragraph>An <strong>invoicing plan</strong> is a rather temporary database object which represents the plan of a given user to have Lino generate a series of invoices.
            </paragraph>
            <index entries="..."/>
        <desc desctype="attribute" objtype="attribute">
            <desc_signature class="Plan" first="False" fullname="Plan.user" ids="..." module="..." names="...">
                <desc_name>user</desc_name>
            </desc_signature>
      <desc_content/>
    </desc>
    <desc desctype="attribute" ... objtype="attribute">
        <desc_signature class="Plan" first="False" fullname="Plan.journal" ids="..." module="..." names="...">
            <desc_name>journal</desc_name>
        </desc_signature>
        <desc_content>
            <paragraph>The journal where to create invoices.  When this field is
            empty, you can fill the plan with suggestions but cannot
            execute the plan.</paragraph>
        </desc_content>
    </desc>
    ...

Example of a field description::

    <desc desctype="attribute" domain="py" noindex="False" objtype="attribute">
      <desc_signature class="Plan" first="False" fullname="Plan.journal" 
            ids="lino_cosi.lib.invoicing.models.Plan.journal" 
            module="lino_cosi.lib.invoicing.models" 
            names="lino_cosi.lib.invoicing.models.Plan.journal">
        <desc_name>journal</desc_name>
      </desc_signature>
      <desc_content>
        <paragraph>
          The journal where to create invoices.  When this field is
          empty, you can fill the plan with suggestions but cannot
          execute the plan.
        </paragraph>
      </desc_content>
    </desc>

'''

from __future__ import print_function
from __future__ import unicode_literals

import os

from docutils import nodes
from docutils import core
from sphinx import addnodes
from sphinx.builders import Builder
# from pprint import pprint

# from importlib import import_module


def node2html(node):
    parts = core.publish_from_doctree(node, writer_name="html")
    return parts['body']


class HelpTextBuilder(Builder):
    name = 'help_texts'

    def __init__(self, *args, **kwargs):
        super(HelpTextBuilder, self).__init__(*args, **kwargs)
        self.texts = dict()
        # self.models = dict()
        # self.node_classes = set()

    def write_doc(self, docname, doctree):
        # if docname != 'api/lino_cosi.lib.invoicing.models':
        #     return
        # print(doctree)
        # return
        # for node in doctree.traverse():
        #     self.node_classes.add(node.__class__)
        for node in doctree.traverse(addnodes.desc):
            if node['domain'] == 'py':
                if node['objtype'] == 'class':
                    self.load_class(node)
                elif node['objtype'] == 'attribute':
                    self.load_attribute(node.parent, node)
        # for node in doctree.traverse(nodes.field):
        #     self.fields.add(node.__class__)

    def load_class(self, node):
        self.store_content(self.texts, node)

    def load_attribute(self, parent, node):
        self.store_content(self.texts, node)

    def store_content(self, d, node):
        sig = []
        content = []
        for c in node.children:
            if isinstance(c, addnodes.desc_content):
                for cc in c.children:
                    if isinstance(cc, nodes.paragraph):
                        p = cc.astext()
                        if not p.startswith("Bases:"):
                            if len(content) == 0:
                                content.append(p)
            elif isinstance(c, addnodes.desc_signature):
                sig.append(c)
        # if len(sig) != 1:
        #     raise Exception("sig is {}!".format(sig))
        sig = sig[0]
        # sig = list(node.traverse(addnodes.desc_signature))[0]
        # content = [
        #     p.astext() for p in node.traverse(addnodes.desc_content)]
        # content = [p for p in content if not p.startswith("Bases:")]
        if not content:
            return
        content = '\n'.join(content)
        if '"""' in content:
            msg = '{} : First paragraph of content may not contain \'"""\'. '
            raise Exception(msg.format(sig['names'][0]))
        if content.startswith('"'):
            content = " " + content
        if content.endswith('"'):
            content += " "
            # msg = '{} : First paragraph of content may not end with \'"\'.'
            # self.warn(msg.format(sig['names'][0]))
        for fn in sig['names']:
            d[fn] = content

    def get_outdated_docs(self):
        return self.env.found_docs
        # for docname in self.env.found_docs:
        #     yield docname

    def prepare_writing(self, docnames):
        pass

    def get_target_uri(self, docname, typ=None):
        return 'help_texts.py'

    def finish(self):
        fn = os.path.join(self.outdir, 'help_texts.py')
        print("Write output to {}".format(fn))
        fd = file(fn, "w")

        def writeln(s):
            s = s.encode('utf-8')
            fd.write(s)
            fd.write("\n")

        writeln("# -*- coding: UTF-8 -*-")
        writeln("# generated by lino.sphinxcontrib.help_text_builder")
        writeln("from __future__ import unicode_literals")
        writeln("from django.utils.translation import ugettext_lazy as _")
        writeln("help_texts = {")
        for k, v in self.texts.items():
            writeln('''    '{}' : _("""{}"""),'''.format(k, v))
        writeln("}")
        fd.close()


def setup(app):
    app.add_builder(HelpTextBuilder)
