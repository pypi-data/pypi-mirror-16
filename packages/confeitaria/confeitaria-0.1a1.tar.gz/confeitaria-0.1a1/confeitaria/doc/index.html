<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/" />
<title>Confeitaria, an experimental web framework for Python</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7614 2013-02-21 15:55:51Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="confeitaria-an-experimental-web-framework-for-python">
<h1 class="title">Confeitaria, an experimental web framework for Python</h1>

<p>Welcome to Confeitaria's documentation! Confeitaria is a Web framework for
Python whose main purpose is to test some hypothesis and possibilities about
Web development. Those hypothesis are the <a class="reference internal" href="#principles">principles</a> behind Confeitaria.
Let's take a look at them... after some initial tests.</p>
<div class="section" id="how-to-use-confeitaria">
<h1>How to use Confeitaria</h1>
<p>The very first use to Confeitaria is to see its own documentation. You should
be able to install Confeitaria with <tt class="docutils literal">pip</tt>:</p>
<pre class="literal-block">
$ pip install confeitaria
</pre>
<p>Now, just run</p>
<pre class="literal-block">
$ python -mconfeitaria
</pre>
<p>and access <a class="reference external" href="http://localhost:8000">http://localhost:8000</a>. Voil√†! You will see this same documentation.</p>
<div class="section" id="creating-and-serving-pages">
<h2>Creating and serving pages</h2>
<p>You would rather show your own page, for sure. In Confeitaria, a page is an
object with a bounded method named <tt class="docutils literal">index()</tt> (henceforward named the <em>index
method</em>) or a bounded method named <tt class="docutils literal">action()</tt> (the <em>action method</em>). The
<em>instances</em> of the class below would be valid pages:</p>
<pre class="literal-block">
&gt;&gt;&gt; class TestPage(object):
...    def index(self):
...        return &quot;This is a test&quot;
</pre>
<p>The simplest way so far of running a Confeitaria object is to use
<tt class="docutils literal">confeitaria.run()</tt>. It starts up a server to serve the return of the
<tt class="docutils literal">index()</tt> method:</p>
<pre class="literal-block">
import confeitaria
page = TestPage()
confeitaria.run(page)
</pre>
<p>If you access <a class="reference external" href="http://localhost:8000">http://localhost:8000</a> after this, you will see <tt class="docutils literal">This is a test</tt>
in the browser.</p>
<!-- One can also create a ``Server`` object, which is more flexible. They are
created and used as below::

    from confeitaria import Server
    page = TestPage()
    server = Server(page)
    server.run()

A nice ``Server`` trick is to start it up through a ``with`` statement. The
server will start in a different process, requests would be possible from the
source code and it would bw shut down after everything is done::

    >>> from confeitaria import Server
    >>> import requests
    >>> page = TestPage()
    >>> with Server(page):
    ...     requests.get('http://localhost:8000').text
    u'This is a test' -->
</div>
<div class="section" id="subpages">
<h2>Subpages</h2>
<p>If the page passed to <tt class="docutils literal">confeitaria.run()</tt> / <tt class="docutils literal">Server</tt> has an attribute, and
this attribute is also a page, then we only need to add the attribute name as
part of the path in the URL to get its output. The attribute page is a subpage
and can has its own subpages. For example, if we have the classes
below:</p>
<pre class="literal-block">
&gt;&gt;&gt; class RootPage(object):
...     def index(self):
...         return 'root'
&gt;&gt;&gt; class SubPage(object):
...     def index(self):
...         return 'a subpage'
&gt;&gt;&gt; class SubSubPage(object):
...     def index(self):
...         return 'another subpage'
</pre>
<p>...and then we build a structure as such:</p>
<pre class="literal-block">
&gt;&gt;&gt; root = RootPage()
&gt;&gt;&gt; root.sub = SubPage()
&gt;&gt;&gt; root.sub.another = SubSubPage()
</pre>
<p>... then we should expect the following responses:</p>
<pre class="literal-block">
&gt;&gt;&gt; with Server(root):
...    requests.get('http://localhost:8000/').text
...    requests.get('http://localhost:8000/sub').text
...    requests.get('http://localhost:8000/sub/another').text
u'root'
u'a subpage'
u'another subpage'
</pre>
</div>
<div class="section" id="index-method-arguments">
<h2>Index method arguments</h2>
<p>Naturally, most pages should get information from the browser. This information
can be passed to the index method by arguments. The values for the arguments are
retrieved from the HTTP request parameters. It can be done in two ways:</p>
<dl class="docutils">
<dt>Query path parameters</dt>
<dd><p class="first">If the index function has mandatory arguments, their values will come
from the query path, as below:</p>
<pre class="literal-block">
&gt;&gt;&gt; class SumPage(object):
...    def index(self, p1, p2):
...        v1, v2 = int(p1), int(p2)
...        return &quot;{0} + {1} = {2}&quot;.format(v1, v2, v1 + v2)
&gt;&gt;&gt; with Server(SumPage()):
...     requests.get('http://localhost:8000/3/2').text
...     requests.get('http://localhost:8000/-2/3').text
u'3 + 2 = 5'
u'-2 + 3 = 1'
</pre>
<p>If the URL path does not a value for the given parameter, a 404 Not Found
response will be served:</p>
<pre class="literal-block">
&gt;&gt;&gt; class NonePage(object):
...    def index(self, arg):
...        return &quot;arg: {0}, arg type: {1}&quot;.format(arg, type(arg))
&gt;&gt;&gt; with Server(NonePage()):
...     requests.get('http://localhost:8000/').status_code
404
</pre>
<p>If the URL path has more values than the number of index method's mandatory
parameters, a 404 Not Found error should be the result:</p>
<pre class="last literal-block">
&gt;&gt;&gt; class NonePage(object):
...    def index(self, arg):
...        return &quot;arg: {0} arg type: {1}&quot;.format(arg, type(arg))
&gt;&gt;&gt; with Server(NonePage()):
...     requests.get('http://localhost:8000/a/b').status_code
404
</pre>
</dd>
<dt>Query string parameters</dt>
<dd><p class="first">If the index function has optional arguments, their values will come
from the query string parameters, as below:</p>
<pre class="last literal-block">
&gt;&gt;&gt; class HelloWorldPage(object):
...    def index(self, greeting='Hello', greeted='World'):
...        return greeting + &quot; &quot; + greeted + &quot;!&quot;
&gt;&gt;&gt; with Server(HelloWorldPage()):
...     requests.get('http://localhost:8000/').text
...     requests.get('http://localhost:8000/?greeting=Hi').text
...     requests.get(
...         'http://localhost:8000/?greeting=Hi&amp;greeted=Earth').text
u'Hello World!'
u'Hi World!'
u'Hi Earth!'
</pre>
</dd>
</dl>
<p>Which one to use is up to the developer. We believe mandatory arguments are
good to pass mandatory identifiers, such as database primary keys and usernames,
as in <tt class="docutils literal"><span class="pre">http://example.com/report/1081</span></tt> or <tt class="docutils literal"><span class="pre">http://example.com/user/juju</span></tt>.
Optional parameters are nice in most other cases, such as when executing
operations (as in <tt class="docutils literal"><span class="pre">http://example.com/user/update?id=324&amp;username=Ju</span></tt>)
or giving extra options (as in <tt class="docutils literal"><span class="pre">http://example.com/report/1081?pages=all</span></tt>).</p>
<blockquote>
<strong>Advanced warning</strong>: what if one wants to give the values for mandatory
arguments with query string parameters (e.g. using the URL
<tt class="docutils literal"><span class="pre">http://localhost:8000/?p2=3&amp;p1=2</span></tt> to hit <tt class="docutils literal">SumPage</tt>) or optional
arguments with path components (generating a URL such as
<tt class="docutils literal"><span class="pre">http://localhost:8000/hello/world</span></tt> to access <tt class="docutils literal">HelloWorldPage</tt>)? This
behavior is undefined on purpose. Confeitaria should play well with many
other frameworks and the best behavior can vary between them. In our
reference implementation, it fails, and we don't think it is a good practice
anyway.</blockquote>
</div>
<div class="section" id="action-methods">
<h2>Action methods</h2>
<p>Index methods only handle GET requests. If a request uses the POST HTTP method,
it should be handled by an action method.</p>
<p>Action methods are not expected to return HTML documents, they are only called
for their side effects. Any relevant content should be returned by an index
method.</p>
<p>Consider, for example, the following mock of an authetication page:</p>
<pre class="literal-block">
&gt;&gt;&gt; class AuthenticationPage(object):
...     username = None
...     def action(self, username=None):
...         AuthenticationPage.username = username
</pre>
<p>It could be a subpage of a root page as the one below:</p>
<pre class="literal-block">
&gt;&gt;&gt; class MainPage(object):
...     def index(self):
...         if AuthenticationPage.username:
...             return 'You are logged in as {0}.'.format(
...                 AuthenticationPage.username
...             )
...         else:
...             return 'You are not logged in.'
</pre>
<p>So we would have this tree:</p>
<pre class="literal-block">
&gt;&gt;&gt; page = MainPage()
&gt;&gt;&gt; page.auth = AuthenticationPage()
</pre>
<p>By default, nobody would be authenticated:</p>
<pre class="literal-block">
&gt;&gt;&gt; with Server(page):
...     requests.get('http://localhost:8000/').text
u'You are not logged in.'
</pre>
<p>We can, however, send a POST request for log in:</p>
<pre class="literal-block">
&gt;&gt;&gt; with Server(page):
...     requests.get('http://localhost:8000/').text
...     _ = requests.post(
...         'http://localhost:8000/auth', data={'username': 'alice'},
...         allow_redirects=False # Why to do it? We'll see... soon.
...     )
...     requests.get('http://localhost:8000/').text
u'You are not logged in.'
u'You are logged in as alice.'
</pre>
</div>
<div class="section" id="knowing-a-page-url">
<h2>Knowing a page URL</h2>
<p>If a page has a bound method named <tt class="docutils literal">set_url()</tt> which receives one argument,
this method will be called and the parameter value will be the URL of the page.
This means that each page can know what is its own URL on the server:</p>
<pre class="literal-block">
&gt;&gt;&gt; class URLAwarePage(object):
...     def set_url(self, url):
...         self.url = url
...     def index(self):
...         return 'My URL is ' + self.url
&gt;&gt;&gt; root = URLAwarePage()
&gt;&gt;&gt; root.sub = URLAwarePage()
&gt;&gt;&gt; with Server(root):
...     requests.get('http://localhost:8000/').text
...     requests.get('http://localhost:8000/sub').text
u'My URL is /'
u'My URL is /sub'
</pre>
<p>This URL is immutable, it is set in the server start up. This means that a page
can even know the URL of its subpages:</p>
<pre class="literal-block">
&gt;&gt;&gt; class RootPage(object):
...     def __init__(self):
...         self.sub = URLAwarePage()
...     def index(self):
...         return (
...             'Subpage is at {0}. '
...             '&lt;a href=&quot;{0}&quot;&gt;Go there!&lt;/a&gt;'.format(self.sub.url)
...         )
&gt;&gt;&gt; with Server(RootPage()):
...     requests.get('http://localhost:8000/').text
u'Subpage is at /sub. &lt;a href=&quot;/sub&quot;&gt;Go there!&lt;/a&gt;'
</pre>
<!--  -->
<blockquote>
<strong>Note</strong>: one could argue that the &quot;URLs&quot; in these examples are actually
just paths, not full URLs. We hope, however, to make it possible to a page
to have a totally different URL, even in another domain. We do not have
this feature now; yet, assuming that the URLs defined with <tt class="docutils literal">set_url()</tt>
can be more complex than paths is the way to go - even if the current
examples are quite simple.</blockquote>
<p>To save you from typing the same method over and over, we also provide the class
<tt class="docutils literal">confeitaria.interface.URLedPage</tt>. It implements this protocol and has a
<tt class="docutils literal">get_url()</tt> method:</p>
<pre class="literal-block">
&gt;&gt;&gt; import confeitaria.interfaces
&gt;&gt;&gt; class URLAwarePage(confeitaria.interfaces.URLedPage):
...     def index(self):
...         return 'My URL is ' + self.get_url()
&gt;&gt;&gt; root = URLAwarePage()
&gt;&gt;&gt; root.sub = URLAwarePage()
&gt;&gt;&gt; with Server(root):
...     requests.get('http://localhost:8000/').text
...     requests.get('http://localhost:8000/sub').text
u'My URL is /'
u'My URL is /sub'
</pre>
</div>
<div class="section" id="getting-the-request">
<h2>Getting the request</h2>
<p>If a page has a bound method named <tt class="docutils literal">set_requests()</tt> with one argument, this
method will be called and the argument value will be an object representing the
HTTP request being processed. This request object can given information, for
example, about query parameters:</p>
<pre class="literal-block">
&gt;&gt;&gt; class ActionPage(object):
...     def set_request(self, request):
...         self.request = request
...     def index(self):
...         return (
...             'The action is ' + self.request.query_args['action']
...         )
&gt;&gt;&gt; page = ActionPage()
&gt;&gt;&gt; with Server(page):
...     requests.get('http://localhost:8000/?action=update').text
u'The action is update'
</pre>
<p>The class <tt class="docutils literal">confeitaria.interfaces.RequestedPage</tt> implements the
<tt class="docutils literal">set_request()</tt> method, as well as a <tt class="docutils literal">get_request()</tt> to retrieve the set
request:</p>
<pre class="literal-block">
&gt;&gt;&gt; class ActionPage(confeitaria.interfaces.RequestedPage):
...     def index(self):
...         request = self.get_request()
...         return (
...             'The action is ' + request.query_args['action']
...         )
&gt;&gt;&gt; page = ActionPage()
&gt;&gt;&gt; with Server(page):
...     requests.get('http://localhost:8000/?action=update').text
u'The action is update'
</pre>
</div>
<div class="section" id="getting-and-sending-cookies">
<h2>Getting and sending cookies</h2>
<p>Cookies are the most standard way of recalling information between different
requests from the same browser. Once a server sends instructos for setting
cookies to a browser, the browser is expected to send this information back
with each request.</p>
<p>If a page has a bound method named <tt class="docutils literal">set_cookies()</tt> with one argument, this
method will be called and the argument value will be an object representing a
set of cookies. This cookies object should behave as the
<a class="reference external" href="https://docs.python.org/2/library/cookie.html#Cookie.SimpleCookie">Cookie.SimpleCookie</a>. Consider,
for example, the cart page below - it stores the number of items in a cookie:</p>
<pre class="literal-block">
&gt;&gt;&gt; class CartPage(object):
...     def set_cookies(self, cookies):
...         self.cookies = cookies
...     def action(self, items=None):
...         if items is not None:
...             self.cookies['items'] = items
...     def index(self):
...         if 'items' in self.cookies:
...             return 'You have {0} items'.format(
...                 self.cookies['items'].value
...             )
...         else:
...             return 'You have no items'
</pre>
<p>The results from using it is:</p>
<pre class="literal-block">
&gt;&gt;&gt; page = CartPage()
&gt;&gt;&gt; with Server(page):
...     requests.get('http://localhost:8000/').text
...     r = requests.post(
...         'http://localhost:8000/', data={'items': '2'},
...         allow_redirects=False
...     )
...     r.cookies['items']
...     requests.get('http://localhost:8000/', cookies=r.cookies).text
u'You have no items'
'2'
u'You have 2 items'
</pre>
<p>If you extend <tt class="docutils literal">confeitaria.interfaces.CookiedPage</tt> you will have a pair of
methods to set a retrieve the cookies:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; class CartPage(confeitaria.interfaces.CookiedPage):
...     def action(self, items=None):
...         if items is not None:
...             self.get_cookies()['items'] = items
...     def index(self):
...         if 'items' in self.get_cookies():
...             cookies = self.get_cookies()
...             return 'You have {0} items'.format(
...                 self.get_cookies()['items'].value
...             )
...         else:
...             return 'You have no items'
&gt;&gt;&gt; page = CartPage()
&gt;&gt;&gt; with Server(page):
...     requests.get('http://localhost:8000/').text
...     r = requests.post(
...         'http://localhost:8000/', data={'items': '2'},
...         allow_redirects=False
...     )
...     r.cookies['items']
...     requests.get('http://localhost:8000/', cookies=r.cookies).text
u'You have no items'
'2'
u'You have 2 items'
</pre>
</blockquote>
</div>
<div class="section" id="using-sessions">
<h2>Using sessions</h2>
<p>If your page needs to preserve state between requests, you can use sessions. To
get a session, just add a <tt class="docutils literal">set_session()</tt> method to your page - as usual, it
should receive an argument, which will be a dict-like session object:</p>
<pre class="literal-block">
&gt;&gt;&gt; class SessionPage(object):
...     def set_session(self, session):
...         self.session = session
...     def action(self, username=None):
...         self.session['username'] = username
...     def index(self):
...         if 'username' in self.session:
...             return 'User: {0}'.format(self.session['username'])
...         else:
...             return 'Not authenticated'
</pre>
<p>The received session is preserved between requests. The default implementation
saves the session variables in memory only and preserve the session through
cookies:</p>
<pre class="literal-block">
&gt;&gt;&gt; page = SessionPage()
&gt;&gt;&gt; with Server(page):
...     r = requests.get('http://localhost:8000/')
...     r.text
...     r = requests.post(
...         'http://localhost:8000/', data={'username': 'juju'},
...         cookies=r.cookies, allow_redirects=False
...     )
...     requests.get('http://localhost:8000/', cookies=r.cookies).text
u'Not authenticated'
u'User: juju'
</pre>
<p>Note that there is no need to handle the cookies directly: in the server,
Confeitaria takes care of this; in the client, the browser should handle it by
itself.</p>
<p>You can also get the request's session by extending
<tt class="docutils literal">confeitaria.interfaces.SessionedPage</tt>. The method
<tt class="docutils literal">confeitaria.interfaces.SessionedPage.get_session()</tt> will return the session
object:</p>
<pre class="literal-block">
&gt;&gt;&gt; class SessionPage(confeitaria.interfaces.SessionedPage):
...     def action(self, username=None):
...         self.get_session()['username'] = username
...     def index(self):
...         if 'username' in self.get_session():
...             return 'User: {0}'.format(self.get_session()['username'])
...         else:
...             return 'Not authenticated'
&gt;&gt;&gt; page = SessionPage()
&gt;&gt;&gt; with Server(page):
...     r = requests.get('http://localhost:8000/')
...     r.text
...     r = requests.post(
...         'http://localhost:8000/', data={'username': 'juju'},
...         cookies=r.cookies, allow_redirects=False
...     )
...     requests.get('http://localhost:8000/', cookies=r.cookies).text
u'Not authenticated'
u'User: juju'
</pre>
</div>
<div class="section" id="the-page-class">
<h2>The <tt class="docutils literal">Page</tt> class</h2>
<p>In practice, we almost always want to have access to the URL page, cookies,
session and the request object. Instead of implementing all the required methods
by hand, or extending all awareness interface classes, we can just extend the
<tt class="docutils literal">confeitaria.interfaces.Page</tt> class, and our page will be aware of all these
informations. Consider, for example, an e-commerce page which stores the user
in session and the cart in the cookies:</p>
<pre class="literal-block">
&gt;&gt;&gt; class ShopPage(confeitaria.interfaces.Page):
...     def index(self):
...         result = &quot;Welcome to {0}. &quot;.format(self.get_url())
...         user = self.get_session().get('username', 'nobody')
...         result += &quot;You are {0}. &quot;.format(user)
...         if 'items' in self.get_cookies():
...             items = self.get_cookies()['items'].value
...         else:
...             items = 0
...         result += &quot;You have {0} items.&quot;.format(items)
...         return result
...     def action(self, username=None, items=None):
...         if username is not None:
...             self.get_session()['username'] = username
...         if items is not None:
...             self.get_cookies()['items'] = items
</pre>
<p>It would yield the following results:</p>
<pre class="literal-block">
&gt;&gt;&gt; page = ShopPage()
&gt;&gt;&gt; with Server(page):
...     r = requests.get('http://localhost:8000/')
...     r.text
...     r = requests.post(
...         'http://localhost:8000/', data={'username': 'juju'},
...         cookies=r.cookies
...     )
...     r.text
...     r = requests.post(
...         'http://localhost:8000/', data={'items': '2'},
...         cookies=r.cookies
...     )
...     r.text
...     r.cookies['items']
u'Welcome to /. You are nobody. You have 0 items.'
u'Welcome to /. You are juju. You have 0 items.'
u'Welcome to /. You are juju. You have 2 items.'
'2'
</pre>
</div>
<div class="section" id="redirecting">
<h2>Redirecting</h2>
<p>HTTP redirect responses are a common need. For example, you may want to redirect
the browser to another URL to where the looked upon content was moved. You just
need to raise the <tt class="docutils literal">confeitaria.responses.MovedPermanently</tt> exception:</p>
<pre class="literal-block">
&gt;&gt;&gt; import confeitaria.responses
&gt;&gt;&gt; class OldPage(object):
...     def index(self):
...         raise confeitaria.responses.MovedPermanently('/new')
&gt;&gt;&gt; class NewPage(object):
...     def index(self):
...         return 'page: new'
&gt;&gt;&gt; page = OldPage()
&gt;&gt;&gt; page.new = NewPage()
&gt;&gt;&gt; with Server(page):
...     r = requests.get('http://localhost:8000/', allow_redirects=False)
...     r.status_code
...     r.headers['location']
301
'/new'
&gt;&gt;&gt; with Server(page):
...     r = requests.get('http://localhost:8000/')
...     r.status_code
...     r.text
200
u'page: new'
</pre>
<p>If, however, one wants to implement the POST-REDIRECT-GET pattern, it is better
to use the <tt class="docutils literal">SeeOther</tt> response:</p>
<pre class="literal-block">
&gt;&gt;&gt; class LoginPage(object):
...     username = None
...     def index(self):
...         if LoginPage.username is None:
...             return 'Nobody is logged in.'
...         else:
...             return '{0} is logged in.'.format(LoginPage.username)
...     def action(self, username=None):
...         LoginPage.username = username
...         raise confeitaria.responses.SeeOther('/')
&gt;&gt;&gt; with Server(LoginPage()):
...     requests.get('http://localhost:8000/').text
...     r = requests.post(
...         'http://localhost:8000/', data={'username': 'bob'}
...     )
...     r.status_code
...     r.text
u'Nobody is logged in.'
200
u'bob is logged in.'
</pre>
<p>If no parameter is given to the <tt class="docutils literal">SeeOther</tt> or <tt class="docutils literal">MovedPermanently</tt>
constructor, the browser will be redirected to the originally requested URL:</p>
<pre class="literal-block">
&gt;&gt;&gt; class RedirectPage(object):
...     def action(self, username=None):
...         raise confeitaria.responses.SeeOther()
&gt;&gt;&gt; with Server(RedirectPage()):
...     r = requests.post(
...         'http://localhost:8000/?a=b', allow_redirects=False
...     )
...     r.status_code
...     r.headers['location']
303
'/?a=b'
</pre>
<p>However, one does not even need to raise the response: if an action method
returns without raising any response, it will redirect to the original URL by
default:</p>
<pre class="literal-block">
&gt;&gt;&gt; class MagicRedirectPage(object):
...     def action(self, username=None):
...         pass
&gt;&gt;&gt; with Server(MagicRedirectPage()):
...     r = requests.post(
...         'http://localhost:8000/?magic=true', allow_redirects=False
...     )
...     r.status_code
...     r.headers['location']
303
'/?magic=true'
</pre>
</div>
</div>
<div class="section" id="principles">
<h1>Principles</h1>
<p>In Confeitaria, we try to follow some principles as much as possible. We do not
know how much they are feasible or advantageus, they are not necessarily
original and we are not saying you have to follow them. We will try, however.</p>
<dl class="docutils">
<dt>Principle 1: <em>The customer should get only the desired piece.</em></dt>
<dd>Confeitaria should provide many applications, each in its own package. They
should be as independent as possible so the developer may use only what is
needed.</dd>
<dt>Principle 2: <em>To use a page should be a piece of cake.</em></dt>
<dd>An application should be pages that can be instatiated many times, maybe
with some pages. The pages should be as flexible as any simple object, not
requiring any setup other than being called by <tt class="docutils literal">confeitaria.run()</tt> (but
being open to more, optional configuration0.</dd>
<dt>Principle 3: <em>A cake should be useful without more cooking.</em></dt>
<dd>Whenever possible, a Confeitaria package should be usable by only calling
it with the Python interpreter's <tt class="docutils literal"><span class="pre">-m</span></tt> flag. For example, the reference
confeitaria module does provide a feature: it displays this same
documenation.</dd>
<dt>Principle 4: <em>The layered cake should be edible without the frosting.</em></dt>
<dd>The Confeitaria pages should have tiers, and the lower one cannot depend on
the higher one. In special, any Confeitaria page should be usable even
without CSS and JavaScript (the &quot;frosting&quot;). CSS and JavaScript should be
added to improve the usabiity of a functioning page. A rule of thumb to
ensure this is that <em>any task should be executed only using ``curl`` or the
``requests`` module</em>.</dd>
<dt>Principle 5: <em>The dough should be tested at each step.</em></dt>
<dd>We should test as much as possible. Each commit set should contain a new
test. We should have unit tests, integration tests, functional tests without
JavaScript and functional tests with JavaScript - probably even JavaScript
tests.</dd>
<dt>Principle 6: <em>The recipes should be written down.</em></dt>
<dd>We should document how to use Confeitaria. Each public method should have a
docstring. Each application page should have a separate document explaining
it. Examples should be doctests.</dd>
<dt>Principle 7: <em>Each order should be written down.</em></dt>
<dd>Each change in the code base should be preceded by a ticket in the issue
tracker.</dd>
<dt>Principle 8: <em>The dough should harmonize with any flavor.</em></dt>
<dd>It should be possible to run add a Confeitaria page to applications in as
many frameworks as possible - such as Django, CherryPy, CGI... This WSGI
implementation is actually a reference implementation - other modules should
not depend on it!</dd>
</dl>
<p>We may add more principles, or give up some of them - that is acceptable. The
main objective here, after all, is to discover what is possible to do.</p>
</div>
</div>
</body>
</html>
