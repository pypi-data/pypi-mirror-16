<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>rstem.led_matrix API documentation</title>
    <meta name="description" content="This module provides interfaces to the LED Matrix Ready Set STEM Cell." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#rstem.led_matrix.FrameBuffer">FrameBuffer</a></span>
        
          
  <ul>
    <li class="mono"><a href="#rstem.led_matrix.FrameBuffer.__init__">__init__</a></li>
    <li class="mono"><a href="#rstem.led_matrix.FrameBuffer.detect">detect</a></li>
    <li class="mono"><a href="#rstem.led_matrix.FrameBuffer.draw">draw</a></li>
    <li class="mono"><a href="#rstem.led_matrix.FrameBuffer.erase">erase</a></li>
    <li class="mono"><a href="#rstem.led_matrix.FrameBuffer.line">line</a></li>
    <li class="mono"><a href="#rstem.led_matrix.FrameBuffer.point">point</a></li>
    <li class="mono"><a href="#rstem.led_matrix.FrameBuffer.rect">rect</a></li>
    <li class="mono"><a href="#rstem.led_matrix.FrameBuffer.show">show</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#rstem.led_matrix.Sprite">Sprite</a></span>
        
          
  <ul>
    <li class="mono"><a href="#rstem.led_matrix.Sprite.__init__">__init__</a></li>
    <li class="mono"><a href="#rstem.led_matrix.Sprite.crop">crop</a></li>
    <li class="mono"><a href="#rstem.led_matrix.Sprite.flip">flip</a></li>
    <li class="mono"><a href="#rstem.led_matrix.Sprite.reset">reset</a></li>
    <li class="mono"><a href="#rstem.led_matrix.Sprite.rotate">rotate</a></li>
    <li class="mono"><a href="#rstem.led_matrix.Sprite.from_file">from_file</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#rstem.led_matrix.Text">Text</a></span>
        
          
  <ul>
    <li class="mono"><a href="#rstem.led_matrix.Text.__init__">__init__</a></li>
    <li class="mono"><a href="#rstem.led_matrix.Text.crop">crop</a></li>
    <li class="mono"><a href="#rstem.led_matrix.Text.flip">flip</a></li>
    <li class="mono"><a href="#rstem.led_matrix.Text.reset">reset</a></li>
    <li class="mono"><a href="#rstem.led_matrix.Text.rotate">rotate</a></li>
    <li class="mono"><a href="#rstem.led_matrix.Text.font_list">font_list</a></li>
    <li class="mono"><a href="#rstem.led_matrix.Text.from_file">from_file</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">rstem.led_matrix</span> module</h1>
  <p>This module provides interfaces to the LED Matrix Ready Set STEM Cell.</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rstem.led_matrix', this);">Show source &equiv;</a></p>
  <div id="source-rstem.led_matrix" class="source">
    <pre><code>#!/usr/bin/env python3
#
# Copyright (c) 2014, Scott Silver Labs, LLC.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
'''
This module provides interfaces to the LED Matrix Ready Set STEM Cell.
'''


import os
import re
import time
from . import led_driver     # c extension that controls led matrices and contains framebuffer
from .. import gpio
import copy
import subprocess
from itertools import islice

MAX_MATRICES = 64
MATRIX_SPI_SHIFT_REGISTER_LENGTH=32
width = 0    #: The width of the LED matrix grid
height = 0   #: The height of the LED matrix grid


def _to_color(color):
    '''Converts the given color to an int.
    @param color: A color to be converted
    @type color: string or int
    
    @raise ValueError: Fails L{_valid_color} check
    
    @return: Either the same int back again if color was an int or the int of a converted string
    @rtype: int
    '''
    if not (isinstance(color, str) and len(color) == 1 and color in '01234567890abcdefABCDEF-'):
        raise ValueError("Invalid Color: must be a string between 0-9 or a-f or '-'")
    return int(color, 16) if color != '-' else -1

def _color_array_to_str(array, height, width):
    s = ''
    for y in reversed(range(height)):
        for x in range(width):
            color = array[x][y]
            s += '{:1X}'.format(color) if color >= 0 else '-'
        s += '\n'
    return s

def _quarter_clockwise_rotations(angle):
    if angle % 90 != 0:
        raise ValueError('angle must be a multiple of 90.')
    return int(angle/90) % 4

class Sprite(object):
    '''A Sprite (2-dimensional bitmapped image) object.

    A `Sprite` is drawable on the LED Matrix `FrameBuffer` with the
    `FrameBuffer`'s `draw()` function.  `Sprite`s support tranparency.

    Two sprites of the same hieght can be added togther, creating a new
    horizontally concatenated composite sprite.
    '''
    def __init__(self, image):
        '''Creates a `Sprite` object from the given `image`.
        
        The `image` defines the bitmap of the `Sprite`.  It is a string
        that contains one line for each row in the `Sprite`.  Each line should
        contains the same number of valid color characters.  All whitespace,
        including blank lines, is ignored.  

        Alternatively, `image` can be a Sprite, and then a new Sprite object
        will be created with the same bitmap of the given `image`.

        Each character in the `image` represents one pixel of the
        `Sprite`.  The characters must be either single hex digits representing
        the color (0-9, a-f, A-F) or - (dash) to represent transparency.

        For example, the following string would define a 3x5 letter P, with a transparent center
        of the P:

            f f f
            f - f
            f f f
            f 0 0
            f 0 0
        '''
        if isinstance(image, Sprite):
            image = str(image)

        # Remove whitespace from lines
        lines = (re.sub('\s', '', line) for line in image.splitlines())
        # remove blank lines
        lines = (line for line in lines if line)
        # Convert chars to integer colors
        reversed_transposed_bitmap = [[_to_color(color) for color in line] for line in lines]
        # Reverse and transpose array
        transposed_bitmap = list(reversed(reversed_transposed_bitmap))
        self.original_bitmap = [list(z) for z in zip(*transposed_bitmap)]

        self.reset()

    @classmethod
    def from_file(cls, filename):
        with open(filename) as f:
            s = cls(f.read())
        return s
        
    def _bitmap(self):
        return self.bitmap

    @property
    def width(self):
        '''Returns the width of the sprite.
        '''
        return len(self.bitmap)

    @property
    def height(self):
        '''Returns the height of the sprite.
        '''
        return len(self.bitmap[0])

    def __add__(self, sprite):
        if self.height != sprite.height:
            raise ValueError("Can only add sprites of the same height")
        self.bitmap += sprite.bitmap
        return self

    def _recreate_bitmap(self, xrange, yrange):
        yrange = list(yrange)
        self.bitmap = [[self.bitmap[x][y] for y in yrange] for x in xrange]

    def crop(self, origin=(0,0), dimensions=None):
        '''In-place crop of the sprite.

        Returns itself, so this function can be chained.
        '''
        x, y = origin
        if x >= self.width:
            raise IndexError('Origin X is greater than Sprite width')
        if y >= self.height:
            raise IndexError('Origin Y is greater than Sprite height')

        try:
            width, height = dimensions
        except TypeError:
            width, height = self.width, self.height

        xrange = range(x, min(x + width, self.width))
        yrange = range(y, min(y + height, self.height))
        self._recreate_bitmap(xrange, yrange)
        return self

    def rotate(self, angle=90):
        '''In-place rotation of the sprite.

        `angle` must be a multiple of 90.

        Returns itself, so this function can be chained.
        '''
        quarter_clockwise_rotations = _quarter_clockwise_rotations(angle)
        if quarter_clockwise_rotations == 0:
            xrange, yrange = range(self.width), range(self.height)
            transposed = False
        elif quarter_clockwise_rotations == 1:
            xrange, yrange = range(self.width), reversed(range(self.height))
            transposed = True
        elif quarter_clockwise_rotations == 2:
            xrange, yrange = reversed(range(self.width)), reversed(range(self.height))
            transposed = False
        elif quarter_clockwise_rotations == 3:
            xrange, yrange = reversed(range(self.width)), range(self.height)
            transposed = True
        else:
            raise RuntimeException('Internal Error: Invalid rotation')
        self._recreate_bitmap(xrange, yrange)
        if transposed:
            self.bitmap = [list(z) for z in zip(*self.bitmap)]
        return self
        
    def flip(self, vertical=False):
        '''In-place horizontal (default) or vertical flip of the sprite.

        Returns itself, so this function can be chained.
        '''
        if vertical:
            xrange, yrange = range(self.width), reversed(range(self.height))
        else:
            xrange, yrange = reversed(range(self.width)), range(self.height)
        self._recreate_bitmap(xrange, yrange)
        return self

    def __str__(self):
        return _color_array_to_str(self.bitmap, self.height, self.width)

    def reset(self):
        '''Undoes previous flip/rotate/crop/etc actions

        Returns itself, so this function can be chained.
        '''
        # When reset, bitmap is the original_bitmap.  Note, though, that
        # because this is a reference, self.bitmap should not be edited
        # in-place (even though it is mutable) - it should be replaced by any
        # operations that do work on it (e.g. flip()).
        self.bitmap = self.original_bitmap
        return self
        
class Text(Sprite):
    '''A string of text writable to the framebuffer.

    `Text` is composed of a concatenated string of `Sprite`s, and as such can
    use all the functions available to `Sprite`s.
    '''
    def __init__(self, message, char_spacing=1, font_name='5x7', font_dir=None):
        '''Create a `Text` object from a string.

        `message` is the text string.  Two fonts are supported: '3x5' and
        '5x7'.  Custom fonts can be created by making one sprite file for each
        letter in the font.  The `font_dir` can be changed from the default to
        point to a custom font.

        `char_spacing` is the number of blank pixels that are put between two
        characters in a string.
        '''
        with open(self._font_path(font_dir, font_name, message[0])) as f:
            super().__init__(f.read())
        if len(message) > 1:
            self.__add__(Sprite((('-' * char_spacing) + '\n') * self.height))
            self.__add__(Text(message[1:], char_spacing=char_spacing, font_name=font_name, font_dir=font_dir))

    @classmethod
    def from_file(cls, filename):
        super().from_file(filename)
        
    @classmethod
    def font_list(cls, font_dir=None):
        font_dir = cls._font_dir(font_dir)
        return [d for d in os.glob(font_dir) if os.path.isdir(d)]

    @staticmethod
    def _font_dir(font_dir=None):
        if font_dir is None:
            this_dir, this_filename = os.path.split(__file__)
            font_dir = os.path.join(this_dir, 'font')
            
        if not os.path.isdir(font_dir):
            raise IOError('Font path does not exist.')

        return font_dir
        
    def _font_path(self, font_dir, font_name, char):
        font_path = os.path.join(self._font_dir(), font_name)
        unknown_font_path = os.path.join(font_path, 'unknown.spr')
        
        if char.isdigit():
            font_path = os.path.join(font_path, 'numbers', char + '.spr')
        elif char.isupper():
            font_path = os.path.join(font_path, 'upper', char + '.spr')
        elif char.islower():
            font_path = os.path.join(font_path, 'lower', char + '.spr')
        elif char.isspace():
            font_path = os.path.join(font_path, 'space.spr')
        else:
            font_path = os.path.join(font_path, 'misc', str(ord(char)) + '.spr')
            
        if not os.path.isfile(font_path):
            return unknown_font_path

        return font_path

class FrameBuffer(object):
    ''' A framebuffer that maps to a chain of LED Matrix Ready Set STEM Cells.  
    
    The LED Matrices are connected over the SPI bus.  The `FrameBuffer` object
    provides a set of functions for drawing on the framebuffer, and for
    writting the framebuffer to the LED Matrices.  All drawing happens on the
    framebuffer only, until the `show()` function is called.

    The LED Matrices can be mapped to any location in the framebuffer, and can
    also have any rotation (0, 90, 180, 270 deg).  The size of the framebuffer
    is the minimum size rectangle that will include all 8x8 LED Matrices in the
    given matrix_layout.  LED Matrices can be mapped on the same or overlapping
    coordinates in the framebuffer.

    The framebuffer uses Cartesian coordinates: the origin (0,0) is at the
    lower left of the framebuffer.

    The framebuffer uses colors from 0-15 for each pixel, where 0 is off, and
    15 is the highest brightness.
    '''

    #
    # Chip enable now controlled manually outside of SPI led_driver.  See
    # led_driver for details.
    #
    SPI_CE0_PIN = 8
    chip_enable = gpio.Output(SPI_CE0_PIN)

    def __init__(self, matrix_layout=None):
        ''' Initialize the `rstem.led_matrix.FrameBuffer`.  
        
        If `matrix_layout` is not given (the default), then the LED Matrix
        chain is autodetected.  To do the autodetection, the LED Matrix chain
        requires that MISO be hooked up, and then the length of the chain can
        be determined.  In this case, the actual layout of the LED Matrices is
        determined from the number of matrices.  The follwing table shows the
        assumed order of the matrices for a given chain length.  The arrows
        show the direction of the input to each matrix in the chain:

            1 matrix:
                --> 1
            2 matrices:
                --> 1 --> 2
            3 matrices:
                --> 1 --> 2 --> 3
            4 matrices:
                --> 1 --> 2 --\\
                              |
                    4 <-- 3 <-/
            5 matrices:
                --> 1 --> 2 --> 3 --> 4 --> 5
            6 matrices:
                --> 1 --> 2 --> 3 --\\
                                    |
                    6 <-- 5 <-- 4 <-/
            7 matrices:
                --> 1 --> 2 --> 3 --> 4 --\\
                                          |
                          7 <-- 6 <-- 5 <-/
            8 matrices:
                --> 1 --> 2 --> 3 --> 4 --\\
                                          |
                    8 <-- 7 <-- 6 <-- 5 <-/
            More than 8 matrices: IOError()

        For arbitrary layouts of matrices, a list of 3-tuples can be provided
        in `matrix_layout`.  There should be one 3-tuple for each LED Matrix in
        the chain, starting with the first matrix.  The 3-tuple should be (x,
        y, rotation), where x/y define the position of the lower left corner
        (after rotation) of the LED Matrix in the Framebuffer.  The rotation is
        a clockwise angle (0, 90, 180, 270) that the LED Matrix is rotated.

        Note that when `matrix_layout` is provided, MISO is not required to be
        hooked up, as it is not used.  This means that the chain will work even
        if the correct number of LED Matrices is not actually hooked up
        (however, not all of the framebuffer data will necessarily be displayed).

        SPI CE0 is always used.
        '''
        if not matrix_layout:
            num_matrices = self.detect()
            if num_matrices == 0:
                raise IOError('No LED Matrices connected')
            elif num_matrices > 8:
                raise IOError(
                    'More than 8 LED Matrices connected - you must define the matrix_layout')
            else:
                matrix_layout = {
                    1 : [(x*8,0,0) for x in range(1)],
                    2 : [(x*8,0,0) for x in range(2)],
                    3 : [(x*8,0,0) for x in range(3)],
                    4 : [(x*8,8,0) for x in range(2)] + [(x*8,0,180) for x in reversed(range(2))],
                    5 : [(x*8,0,0) for x in range(5)],
                    6 : [(x*8,8,0) for x in range(3)] + [(x*8,0,180) for x in reversed(range(3))],
                    7 : [(x*8,8,0) for x in range(4)] + [(x*8,0,180) for x in reversed(range(3))],
                    8 : [(x*8,8,0) for x in range(4)] + [(x*8,0,180) for x in reversed(range(4))],
                }[num_matrices]
        xlist = [x for x,y,angle in matrix_layout]
        ylist = [y for x,y,angle in matrix_layout]
        maxx, maxy = max(xlist), max(ylist)
        minx, miny = min(xlist), min(ylist)
        if minx < 0 or miny < 0:
            raise ValueError('All matrix_layout origins must be greater than zero (x and y)')

        # Convert angles to quarter_clockwise_rotations
        matrix_layout = \
            [(x, y, _quarter_clockwise_rotations(angle)) for x, y, angle in matrix_layout]

        self.matrix_layout = matrix_layout
        self.fb = [[0]*(maxy + 8) for i in range(maxx + 8)]
        led_driver.init_spi()

    def _framebuffer(self):
        return self.fb

    def point(self, x, y=None, color=0xF):
        ''' Draw point (`x`, `y`) in the framebuffer, using the given `color`.

        For convenience, this function accepts a 2-tuple point as `x` if `y` is
        None.  So, for example, both of the following are allowed:

            fb.point(2,3)

        or

            fb.point((2,3))

        The point is drawn in the given `color`.
        '''
        try:
            if y == None:
                x, y = x
            if x < 0 or y < 0:
                raise IndexError
            if color >= 0:
                self.fb[x][y] = color
        except IndexError:
            pass

    def erase(self, color=0):
        '''Erase all pixels in the framebuffer

        `color`, if given, can fill the framebuffer with a specific color.
        '''
        for x in range(self.width):
            for y in range(self.height):
                self.fb[x][y] = color

    def line(self, point_a, point_b, color=0xF):
        '''Draw a line in the framebuffer from `point_a` to `point_b`.

        The line is drawn with the given `color`.
        '''
        # Uses Bresenham's Line Algorithm
        # http://en.wikipedia.org/wiki/Bresenham's_line_algorithm
        x1, y1 = point_a
        x2, y2 = point_b
        dx = abs(x2 - x1)
        dy = abs(y2 - y1)
        sx = 1 if x1 < x2 else -1
        sy = 1 if y1 < y2 else -1
        err = dx - dy
        while True:
            self.point(x1, y1, color)
            if (x1 == x2 and y1 == y2) or x1 >= self.width or y1 >= self.height:
                break
            e2 = 2*err
            if e2 > -dy:
                err -= dy
                x1 += sx
            if e2 < dx:
                err += dx
                y1 += sy

    def rect(self, origin, dimensions, fill=False, color=0xF):
        '''Draws a rectangle in the framebuffer.

        The `origin` is the lower left position of the rectangle.  The
        `dimensions` is a 2-tuple of the width and height.  A width and height
        of 1 would be a 1 point rectangle.

        If `fill` is True, then the interior of the rectanle will be filled.
        Otherwise, only the outside edge of the rectandle will be drawn.  The
        rectangle is drawn in the given `color`.
        '''
        x, y = origin
        width, height = dimensions

        if fill:
            for x_offset in range(width):
                self.line((x + x_offset, y), (x + x_offset, y + height - 1), color)
        else:
            self.line((x, y), (x, y + height - 1), color)
            self.line((x, y + height - 1), (x + width - 1, y + height - 1), color)
            self.line((x + width - 1, y + height - 1), (x + width - 1, y), color)
            self.line((x + width - 1, y), (x, y), color)
        
    def show(self):
        '''Send the framebuffer to the LED Matrices.

        Sends the current framebuffer to the LED Matrices over the SPI bus,
        according to the layout defined when the framebuffer was initialized.
        This will cause the framebuffer to be displayed on the LED Matrix(es).
        '''
        bitstream = b''
        for xoff, yoff, quarter_clockwise_rotations in reversed(self.matrix_layout):
            forward = range(8)
            backward = list(reversed(forward))
            if quarter_clockwise_rotations == 0:
                flat = [self.fb[xoff + x][yoff + y] for x in forward for y in forward]
            elif quarter_clockwise_rotations == 1:
                flat = [self.fb[xoff + x][yoff + y] for y in backward for x in forward]
            elif quarter_clockwise_rotations == 2:
                flat = [self.fb[xoff + x][yoff + y] for x in backward for y in backward]
            elif quarter_clockwise_rotations == 3:
                flat = [self.fb[xoff + x][yoff + y] for y in forward for x in backward]
            else:
                raise RuntimeException('Internal Error: Invalid rotation')
            even = flat[::2]
            odd = flat[1::2]
            bitstream += bytes(b[0] | (b[1] << 4) for b in zip(even, odd))
        FrameBuffer.chip_enable.on()
        led_driver.send(bitstream)
        FrameBuffer.chip_enable.off()

    @staticmethod
    def detect():
        '''Returns the number of matrices connected.  
        
        Requires matrices connected in a full chain from MOSI back to MISO on
        the Raspberry Pi.
        '''
        led_driver.init_spi()

        # Matrix chain forms one long shift-register, of N * B, where N is the
        # number of matrices, and B is the length of the shift-register in each
        # matrix (32 bytes)
        #
        # If we assume there is some MAX number of matrices we won't exceed, we
        # can detect the length by push a string of bytes longer than the max
        # through the chain.
        rand = os.urandom(32)
        sequence = rand + bytes(MAX_MATRICES * MATRIX_SPI_SHIFT_REGISTER_LENGTH)
        FrameBuffer.chip_enable.on()
        recv = led_driver.send(sequence)
        FrameBuffer.chip_enable.off()

        # Search the received bytes for the random sequence.  The offset
        # determines the number of matrices in the chain
        for i in range(MAX_MATRICES + 2):
            start = i*MATRIX_SPI_SHIFT_REGISTER_LENGTH
            end = start + MATRIX_SPI_SHIFT_REGISTER_LENGTH
            if rand == recv[start:end]:
                break
        if i > MAX_MATRICES:
            raise IOError('Could not determine length of LED Matrix chain.')
        return i

    @property
    def width(self):
        '''Returns the width of the framebuffer.

        The width depends upon the matrix layout.
        '''
        return len(self.fb)

    @property
    def height(self):
        '''Returns the height of the framebuffer.

        The height depends upon the matrix layout.
        '''
        return len(self.fb[0])

    def __str__(self):
        return _color_array_to_str(self.fb, self.height, self.width)

    def draw(self, drawable, origin=(0,0)):
        '''Draw `drawable` into the framebuffer, at given origin.

        `drawable` is either a `Sprite` or `Text` object.
        '''
        xorig, yorig = origin
        bitmap = drawable._bitmap()
        if not bitmap:
            return
        width, height = len(bitmap), len(bitmap[0])
        for x in range(width):
            for y in range(height):
                self.point(xorig + x, yorig + y, bitmap[x][y])

__all__ = ['FrameBuffer', 'Sprite', 'Text']
        
</code></pre>
  </div>

  </header>

  <section id="section-items">


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="rstem.led_matrix.FrameBuffer" class="name">class <span class="ident">FrameBuffer</span></p>
      
  
    <div class="desc"><p>A framebuffer that maps to a chain of LED Matrix Ready Set STEM Cells.  </p>
<p>The LED Matrices are connected over the SPI bus.  The <code>FrameBuffer</code> object
provides a set of functions for drawing on the framebuffer, and for
writting the framebuffer to the LED Matrices.  All drawing happens on the
framebuffer only, until the <code>show()</code> function is called.</p>
<p>The LED Matrices can be mapped to any location in the framebuffer, and can
also have any rotation (0, 90, 180, 270 deg).  The size of the framebuffer
is the minimum size rectangle that will include all 8x8 LED Matrices in the
given matrix_layout.  LED Matrices can be mapped on the same or overlapping
coordinates in the framebuffer.</p>
<p>The framebuffer uses Cartesian coordinates: the origin (0,0) is at the
lower left of the framebuffer.</p>
<p>The framebuffer uses colors from 0-15 for each pixel, where 0 is off, and
15 is the highest brightness.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rstem.led_matrix.FrameBuffer', this);">Show source &equiv;</a></p>
  <div id="source-rstem.led_matrix.FrameBuffer" class="source">
    <pre><code>class FrameBuffer(object):
    ''' A framebuffer that maps to a chain of LED Matrix Ready Set STEM Cells.  
    
    The LED Matrices are connected over the SPI bus.  The `FrameBuffer` object
    provides a set of functions for drawing on the framebuffer, and for
    writting the framebuffer to the LED Matrices.  All drawing happens on the
    framebuffer only, until the `show()` function is called.

    The LED Matrices can be mapped to any location in the framebuffer, and can
    also have any rotation (0, 90, 180, 270 deg).  The size of the framebuffer
    is the minimum size rectangle that will include all 8x8 LED Matrices in the
    given matrix_layout.  LED Matrices can be mapped on the same or overlapping
    coordinates in the framebuffer.

    The framebuffer uses Cartesian coordinates: the origin (0,0) is at the
    lower left of the framebuffer.

    The framebuffer uses colors from 0-15 for each pixel, where 0 is off, and
    15 is the highest brightness.
    '''

    #
    # Chip enable now controlled manually outside of SPI led_driver.  See
    # led_driver for details.
    #
    SPI_CE0_PIN = 8
    chip_enable = gpio.Output(SPI_CE0_PIN)

    def __init__(self, matrix_layout=None):
        ''' Initialize the `rstem.led_matrix.FrameBuffer`.  
        
        If `matrix_layout` is not given (the default), then the LED Matrix
        chain is autodetected.  To do the autodetection, the LED Matrix chain
        requires that MISO be hooked up, and then the length of the chain can
        be determined.  In this case, the actual layout of the LED Matrices is
        determined from the number of matrices.  The follwing table shows the
        assumed order of the matrices for a given chain length.  The arrows
        show the direction of the input to each matrix in the chain:

            1 matrix:
                --> 1
            2 matrices:
                --> 1 --> 2
            3 matrices:
                --> 1 --> 2 --> 3
            4 matrices:
                --> 1 --> 2 --\\
                              |
                    4 <-- 3 <-/
            5 matrices:
                --> 1 --> 2 --> 3 --> 4 --> 5
            6 matrices:
                --> 1 --> 2 --> 3 --\\
                                    |
                    6 <-- 5 <-- 4 <-/
            7 matrices:
                --> 1 --> 2 --> 3 --> 4 --\\
                                          |
                          7 <-- 6 <-- 5 <-/
            8 matrices:
                --> 1 --> 2 --> 3 --> 4 --\\
                                          |
                    8 <-- 7 <-- 6 <-- 5 <-/
            More than 8 matrices: IOError()

        For arbitrary layouts of matrices, a list of 3-tuples can be provided
        in `matrix_layout`.  There should be one 3-tuple for each LED Matrix in
        the chain, starting with the first matrix.  The 3-tuple should be (x,
        y, rotation), where x/y define the position of the lower left corner
        (after rotation) of the LED Matrix in the Framebuffer.  The rotation is
        a clockwise angle (0, 90, 180, 270) that the LED Matrix is rotated.

        Note that when `matrix_layout` is provided, MISO is not required to be
        hooked up, as it is not used.  This means that the chain will work even
        if the correct number of LED Matrices is not actually hooked up
        (however, not all of the framebuffer data will necessarily be displayed).

        SPI CE0 is always used.
        '''
        if not matrix_layout:
            num_matrices = self.detect()
            if num_matrices == 0:
                raise IOError('No LED Matrices connected')
            elif num_matrices > 8:
                raise IOError(
                    'More than 8 LED Matrices connected - you must define the matrix_layout')
            else:
                matrix_layout = {
                    1 : [(x*8,0,0) for x in range(1)],
                    2 : [(x*8,0,0) for x in range(2)],
                    3 : [(x*8,0,0) for x in range(3)],
                    4 : [(x*8,8,0) for x in range(2)] + [(x*8,0,180) for x in reversed(range(2))],
                    5 : [(x*8,0,0) for x in range(5)],
                    6 : [(x*8,8,0) for x in range(3)] + [(x*8,0,180) for x in reversed(range(3))],
                    7 : [(x*8,8,0) for x in range(4)] + [(x*8,0,180) for x in reversed(range(3))],
                    8 : [(x*8,8,0) for x in range(4)] + [(x*8,0,180) for x in reversed(range(4))],
                }[num_matrices]
        xlist = [x for x,y,angle in matrix_layout]
        ylist = [y for x,y,angle in matrix_layout]
        maxx, maxy = max(xlist), max(ylist)
        minx, miny = min(xlist), min(ylist)
        if minx < 0 or miny < 0:
            raise ValueError('All matrix_layout origins must be greater than zero (x and y)')

        # Convert angles to quarter_clockwise_rotations
        matrix_layout = \
            [(x, y, _quarter_clockwise_rotations(angle)) for x, y, angle in matrix_layout]

        self.matrix_layout = matrix_layout
        self.fb = [[0]*(maxy + 8) for i in range(maxx + 8)]
        led_driver.init_spi()

    def _framebuffer(self):
        return self.fb

    def point(self, x, y=None, color=0xF):
        ''' Draw point (`x`, `y`) in the framebuffer, using the given `color`.

        For convenience, this function accepts a 2-tuple point as `x` if `y` is
        None.  So, for example, both of the following are allowed:

            fb.point(2,3)

        or

            fb.point((2,3))

        The point is drawn in the given `color`.
        '''
        try:
            if y == None:
                x, y = x
            if x < 0 or y < 0:
                raise IndexError
            if color >= 0:
                self.fb[x][y] = color
        except IndexError:
            pass

    def erase(self, color=0):
        '''Erase all pixels in the framebuffer

        `color`, if given, can fill the framebuffer with a specific color.
        '''
        for x in range(self.width):
            for y in range(self.height):
                self.fb[x][y] = color

    def line(self, point_a, point_b, color=0xF):
        '''Draw a line in the framebuffer from `point_a` to `point_b`.

        The line is drawn with the given `color`.
        '''
        # Uses Bresenham's Line Algorithm
        # http://en.wikipedia.org/wiki/Bresenham's_line_algorithm
        x1, y1 = point_a
        x2, y2 = point_b
        dx = abs(x2 - x1)
        dy = abs(y2 - y1)
        sx = 1 if x1 < x2 else -1
        sy = 1 if y1 < y2 else -1
        err = dx - dy
        while True:
            self.point(x1, y1, color)
            if (x1 == x2 and y1 == y2) or x1 >= self.width or y1 >= self.height:
                break
            e2 = 2*err
            if e2 > -dy:
                err -= dy
                x1 += sx
            if e2 < dx:
                err += dx
                y1 += sy

    def rect(self, origin, dimensions, fill=False, color=0xF):
        '''Draws a rectangle in the framebuffer.

        The `origin` is the lower left position of the rectangle.  The
        `dimensions` is a 2-tuple of the width and height.  A width and height
        of 1 would be a 1 point rectangle.

        If `fill` is True, then the interior of the rectanle will be filled.
        Otherwise, only the outside edge of the rectandle will be drawn.  The
        rectangle is drawn in the given `color`.
        '''
        x, y = origin
        width, height = dimensions

        if fill:
            for x_offset in range(width):
                self.line((x + x_offset, y), (x + x_offset, y + height - 1), color)
        else:
            self.line((x, y), (x, y + height - 1), color)
            self.line((x, y + height - 1), (x + width - 1, y + height - 1), color)
            self.line((x + width - 1, y + height - 1), (x + width - 1, y), color)
            self.line((x + width - 1, y), (x, y), color)
        
    def show(self):
        '''Send the framebuffer to the LED Matrices.

        Sends the current framebuffer to the LED Matrices over the SPI bus,
        according to the layout defined when the framebuffer was initialized.
        This will cause the framebuffer to be displayed on the LED Matrix(es).
        '''
        bitstream = b''
        for xoff, yoff, quarter_clockwise_rotations in reversed(self.matrix_layout):
            forward = range(8)
            backward = list(reversed(forward))
            if quarter_clockwise_rotations == 0:
                flat = [self.fb[xoff + x][yoff + y] for x in forward for y in forward]
            elif quarter_clockwise_rotations == 1:
                flat = [self.fb[xoff + x][yoff + y] for y in backward for x in forward]
            elif quarter_clockwise_rotations == 2:
                flat = [self.fb[xoff + x][yoff + y] for x in backward for y in backward]
            elif quarter_clockwise_rotations == 3:
                flat = [self.fb[xoff + x][yoff + y] for y in forward for x in backward]
            else:
                raise RuntimeException('Internal Error: Invalid rotation')
            even = flat[::2]
            odd = flat[1::2]
            bitstream += bytes(b[0] | (b[1] << 4) for b in zip(even, odd))
        FrameBuffer.chip_enable.on()
        led_driver.send(bitstream)
        FrameBuffer.chip_enable.off()

    @staticmethod
    def detect():
        '''Returns the number of matrices connected.  
        
        Requires matrices connected in a full chain from MOSI back to MISO on
        the Raspberry Pi.
        '''
        led_driver.init_spi()

        # Matrix chain forms one long shift-register, of N * B, where N is the
        # number of matrices, and B is the length of the shift-register in each
        # matrix (32 bytes)
        #
        # If we assume there is some MAX number of matrices we won't exceed, we
        # can detect the length by push a string of bytes longer than the max
        # through the chain.
        rand = os.urandom(32)
        sequence = rand + bytes(MAX_MATRICES * MATRIX_SPI_SHIFT_REGISTER_LENGTH)
        FrameBuffer.chip_enable.on()
        recv = led_driver.send(sequence)
        FrameBuffer.chip_enable.off()

        # Search the received bytes for the random sequence.  The offset
        # determines the number of matrices in the chain
        for i in range(MAX_MATRICES + 2):
            start = i*MATRIX_SPI_SHIFT_REGISTER_LENGTH
            end = start + MATRIX_SPI_SHIFT_REGISTER_LENGTH
            if rand == recv[start:end]:
                break
        if i > MAX_MATRICES:
            raise IOError('Could not determine length of LED Matrix chain.')
        return i

    @property
    def width(self):
        '''Returns the width of the framebuffer.

        The width depends upon the matrix layout.
        '''
        return len(self.fb)

    @property
    def height(self):
        '''Returns the height of the framebuffer.

        The height depends upon the matrix layout.
        '''
        return len(self.fb[0])

    def __str__(self):
        return _color_array_to_str(self.fb, self.height, self.width)

    def draw(self, drawable, origin=(0,0)):
        '''Draw `drawable` into the framebuffer, at given origin.

        `drawable` is either a `Sprite` or `Text` object.
        '''
        xorig, yorig = origin
        bitmap = drawable._bitmap()
        if not bitmap:
            return
        width, height = len(bitmap), len(bitmap[0])
        for x in range(width):
            for y in range(height):
                self.point(xorig + x, yorig + y, bitmap[x][y])
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#rstem.led_matrix.FrameBuffer">FrameBuffer</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="rstem.led_matrix.FrameBuffer.SPI_CE0_PIN" class="name">var <span class="ident">SPI_CE0_PIN</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="rstem.led_matrix.FrameBuffer.chip_enable" class="name">var <span class="ident">chip_enable</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="rstem.led_matrix.FrameBuffer.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, matrix_layout=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize the <a href="#rstem.led_matrix.FrameBuffer"><code>FrameBuffer</code></a>.  </p>
<p>If <code>matrix_layout</code> is not given (the default), then the LED Matrix
chain is autodetected.  To do the autodetection, the LED Matrix chain
requires that MISO be hooked up, and then the length of the chain can
be determined.  In this case, the actual layout of the LED Matrices is
determined from the number of matrices.  The follwing table shows the
assumed order of the matrices for a given chain length.  The arrows
show the direction of the input to each matrix in the chain:</p>
<pre><code>1 matrix:
    --&gt; 1
2 matrices:
    --&gt; 1 --&gt; 2
3 matrices:
    --&gt; 1 --&gt; 2 --&gt; 3
4 matrices:
    --&gt; 1 --&gt; 2 --\
                  |
        4 &lt;-- 3 &lt;-/
5 matrices:
    --&gt; 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5
6 matrices:
    --&gt; 1 --&gt; 2 --&gt; 3 --\
                        |
        6 &lt;-- 5 &lt;-- 4 &lt;-/
7 matrices:
    --&gt; 1 --&gt; 2 --&gt; 3 --&gt; 4 --\
                              |
              7 &lt;-- 6 &lt;-- 5 &lt;-/
8 matrices:
    --&gt; 1 --&gt; 2 --&gt; 3 --&gt; 4 --\
                              |
        8 &lt;-- 7 &lt;-- 6 &lt;-- 5 &lt;-/
More than 8 matrices: IOError()
</code></pre>
<p>For arbitrary layouts of matrices, a list of 3-tuples can be provided
in <code>matrix_layout</code>.  There should be one 3-tuple for each LED Matrix in
the chain, starting with the first matrix.  The 3-tuple should be (x,
y, rotation), where x/y define the position of the lower left corner
(after rotation) of the LED Matrix in the Framebuffer.  The rotation is
a clockwise angle (0, 90, 180, 270) that the LED Matrix is rotated.</p>
<p>Note that when <code>matrix_layout</code> is provided, MISO is not required to be
hooked up, as it is not used.  This means that the chain will work even
if the correct number of LED Matrices is not actually hooked up
(however, not all of the framebuffer data will necessarily be displayed).</p>
<p>SPI CE0 is always used.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rstem.led_matrix.FrameBuffer.__init__', this);">Show source &equiv;</a></p>
  <div id="source-rstem.led_matrix.FrameBuffer.__init__" class="source">
    <pre><code>def __init__(self, matrix_layout=None):
    ''' Initialize the `rstem.led_matrix.FrameBuffer`.  
    
    If `matrix_layout` is not given (the default), then the LED Matrix
    chain is autodetected.  To do the autodetection, the LED Matrix chain
    requires that MISO be hooked up, and then the length of the chain can
    be determined.  In this case, the actual layout of the LED Matrices is
    determined from the number of matrices.  The follwing table shows the
    assumed order of the matrices for a given chain length.  The arrows
    show the direction of the input to each matrix in the chain:
        1 matrix:
            --> 1
        2 matrices:
            --> 1 --> 2
        3 matrices:
            --> 1 --> 2 --> 3
        4 matrices:
            --> 1 --> 2 --\\
                          |
                4 <-- 3 <-/
        5 matrices:
            --> 1 --> 2 --> 3 --> 4 --> 5
        6 matrices:
            --> 1 --> 2 --> 3 --\\
                                |
                6 <-- 5 <-- 4 <-/
        7 matrices:
            --> 1 --> 2 --> 3 --> 4 --\\
                                      |
                      7 <-- 6 <-- 5 <-/
        8 matrices:
            --> 1 --> 2 --> 3 --> 4 --\\
                                      |
                8 <-- 7 <-- 6 <-- 5 <-/
        More than 8 matrices: IOError()
    For arbitrary layouts of matrices, a list of 3-tuples can be provided
    in `matrix_layout`.  There should be one 3-tuple for each LED Matrix in
    the chain, starting with the first matrix.  The 3-tuple should be (x,
    y, rotation), where x/y define the position of the lower left corner
    (after rotation) of the LED Matrix in the Framebuffer.  The rotation is
    a clockwise angle (0, 90, 180, 270) that the LED Matrix is rotated.
    Note that when `matrix_layout` is provided, MISO is not required to be
    hooked up, as it is not used.  This means that the chain will work even
    if the correct number of LED Matrices is not actually hooked up
    (however, not all of the framebuffer data will necessarily be displayed).
    SPI CE0 is always used.
    '''
    if not matrix_layout:
        num_matrices = self.detect()
        if num_matrices == 0:
            raise IOError('No LED Matrices connected')
        elif num_matrices > 8:
            raise IOError(
                'More than 8 LED Matrices connected - you must define the matrix_layout')
        else:
            matrix_layout = {
                1 : [(x*8,0,0) for x in range(1)],
                2 : [(x*8,0,0) for x in range(2)],
                3 : [(x*8,0,0) for x in range(3)],
                4 : [(x*8,8,0) for x in range(2)] + [(x*8,0,180) for x in reversed(range(2))],
                5 : [(x*8,0,0) for x in range(5)],
                6 : [(x*8,8,0) for x in range(3)] + [(x*8,0,180) for x in reversed(range(3))],
                7 : [(x*8,8,0) for x in range(4)] + [(x*8,0,180) for x in reversed(range(3))],
                8 : [(x*8,8,0) for x in range(4)] + [(x*8,0,180) for x in reversed(range(4))],
            }[num_matrices]
    xlist = [x for x,y,angle in matrix_layout]
    ylist = [y for x,y,angle in matrix_layout]
    maxx, maxy = max(xlist), max(ylist)
    minx, miny = min(xlist), min(ylist)
    if minx < 0 or miny < 0:
        raise ValueError('All matrix_layout origins must be greater than zero (x and y)')
    # Convert angles to quarter_clockwise_rotations
    matrix_layout = \
        [(x, y, _quarter_clockwise_rotations(angle)) for x, y, angle in matrix_layout]
    self.matrix_layout = matrix_layout
    self.fb = [[0]*(maxy + 8) for i in range(maxx + 8)]
    led_driver.init_spi()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="rstem.led_matrix.FrameBuffer.detect">
    <p>def <span class="ident">detect</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the number of matrices connected.  </p>
<p>Requires matrices connected in a full chain from MOSI back to MISO on
the Raspberry Pi.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rstem.led_matrix.FrameBuffer.detect', this);">Show source &equiv;</a></p>
  <div id="source-rstem.led_matrix.FrameBuffer.detect" class="source">
    <pre><code>@staticmethod
def detect():
    '''Returns the number of matrices connected.  
    
    Requires matrices connected in a full chain from MOSI back to MISO on
    the Raspberry Pi.
    '''
    led_driver.init_spi()
    # Matrix chain forms one long shift-register, of N * B, where N is the
    # number of matrices, and B is the length of the shift-register in each
    # matrix (32 bytes)
    #
    # If we assume there is some MAX number of matrices we won't exceed, we
    # can detect the length by push a string of bytes longer than the max
    # through the chain.
    rand = os.urandom(32)
    sequence = rand + bytes(MAX_MATRICES * MATRIX_SPI_SHIFT_REGISTER_LENGTH)
    FrameBuffer.chip_enable.on()
    recv = led_driver.send(sequence)
    FrameBuffer.chip_enable.off()
    # Search the received bytes for the random sequence.  The offset
    # determines the number of matrices in the chain
    for i in range(MAX_MATRICES + 2):
        start = i*MATRIX_SPI_SHIFT_REGISTER_LENGTH
        end = start + MATRIX_SPI_SHIFT_REGISTER_LENGTH
        if rand == recv[start:end]:
            break
    if i > MAX_MATRICES:
        raise IOError('Could not determine length of LED Matrix chain.')
    return i
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="rstem.led_matrix.FrameBuffer.draw">
    <p>def <span class="ident">draw</span>(</p><p>self, drawable, origin=(0, 0))</p>
    </div>
    

    
  
    <div class="desc"><p>Draw <code>drawable</code> into the framebuffer, at given origin.</p>
<p><code>drawable</code> is either a <code>Sprite</code> or <code>Text</code> object.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rstem.led_matrix.FrameBuffer.draw', this);">Show source &equiv;</a></p>
  <div id="source-rstem.led_matrix.FrameBuffer.draw" class="source">
    <pre><code>def draw(self, drawable, origin=(0,0)):
    '''Draw `drawable` into the framebuffer, at given origin.
    `drawable` is either a `Sprite` or `Text` object.
    '''
    xorig, yorig = origin
    bitmap = drawable._bitmap()
    if not bitmap:
        return
    width, height = len(bitmap), len(bitmap[0])
    for x in range(width):
        for y in range(height):
            self.point(xorig + x, yorig + y, bitmap[x][y])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="rstem.led_matrix.FrameBuffer.erase">
    <p>def <span class="ident">erase</span>(</p><p>self, color=0)</p>
    </div>
    

    
  
    <div class="desc"><p>Erase all pixels in the framebuffer</p>
<p><code>color</code>, if given, can fill the framebuffer with a specific color.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rstem.led_matrix.FrameBuffer.erase', this);">Show source &equiv;</a></p>
  <div id="source-rstem.led_matrix.FrameBuffer.erase" class="source">
    <pre><code>def erase(self, color=0):
    '''Erase all pixels in the framebuffer
    `color`, if given, can fill the framebuffer with a specific color.
    '''
    for x in range(self.width):
        for y in range(self.height):
            self.fb[x][y] = color
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="rstem.led_matrix.FrameBuffer.line">
    <p>def <span class="ident">line</span>(</p><p>self, point_a, point_b, color=15)</p>
    </div>
    

    
  
    <div class="desc"><p>Draw a line in the framebuffer from <code>point_a</code> to <code>point_b</code>.</p>
<p>The line is drawn with the given <code>color</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rstem.led_matrix.FrameBuffer.line', this);">Show source &equiv;</a></p>
  <div id="source-rstem.led_matrix.FrameBuffer.line" class="source">
    <pre><code>def line(self, point_a, point_b, color=0xF):
    '''Draw a line in the framebuffer from `point_a` to `point_b`.
    The line is drawn with the given `color`.
    '''
    # Uses Bresenham's Line Algorithm
    # http://en.wikipedia.org/wiki/Bresenham's_line_algorithm
    x1, y1 = point_a
    x2, y2 = point_b
    dx = abs(x2 - x1)
    dy = abs(y2 - y1)
    sx = 1 if x1 < x2 else -1
    sy = 1 if y1 < y2 else -1
    err = dx - dy
    while True:
        self.point(x1, y1, color)
        if (x1 == x2 and y1 == y2) or x1 >= self.width or y1 >= self.height:
            break
        e2 = 2*err
        if e2 > -dy:
            err -= dy
            x1 += sx
        if e2 < dx:
            err += dx
            y1 += sy
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="rstem.led_matrix.FrameBuffer.point">
    <p>def <span class="ident">point</span>(</p><p>self, x, y=None, color=15)</p>
    </div>
    

    
  
    <div class="desc"><p>Draw point (<code>x</code>, <code>y</code>) in the framebuffer, using the given <code>color</code>.</p>
<p>For convenience, this function accepts a 2-tuple point as <code>x</code> if <code>y</code> is
None.  So, for example, both of the following are allowed:</p>
<pre><code>fb.point(2,3)
</code></pre>
<p>or</p>
<pre><code>fb.point((2,3))
</code></pre>
<p>The point is drawn in the given <code>color</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rstem.led_matrix.FrameBuffer.point', this);">Show source &equiv;</a></p>
  <div id="source-rstem.led_matrix.FrameBuffer.point" class="source">
    <pre><code>def point(self, x, y=None, color=0xF):
    ''' Draw point (`x`, `y`) in the framebuffer, using the given `color`.
    For convenience, this function accepts a 2-tuple point as `x` if `y` is
    None.  So, for example, both of the following are allowed:
        fb.point(2,3)
    or
        fb.point((2,3))
    The point is drawn in the given `color`.
    '''
    try:
        if y == None:
            x, y = x
        if x < 0 or y < 0:
            raise IndexError
        if color >= 0:
            self.fb[x][y] = color
    except IndexError:
        pass
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="rstem.led_matrix.FrameBuffer.rect">
    <p>def <span class="ident">rect</span>(</p><p>self, origin, dimensions, fill=False, color=15)</p>
    </div>
    

    
  
    <div class="desc"><p>Draws a rectangle in the framebuffer.</p>
<p>The <code>origin</code> is the lower left position of the rectangle.  The
<code>dimensions</code> is a 2-tuple of the width and height.  A width and height
of 1 would be a 1 point rectangle.</p>
<p>If <code>fill</code> is True, then the interior of the rectanle will be filled.
Otherwise, only the outside edge of the rectandle will be drawn.  The
rectangle is drawn in the given <code>color</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rstem.led_matrix.FrameBuffer.rect', this);">Show source &equiv;</a></p>
  <div id="source-rstem.led_matrix.FrameBuffer.rect" class="source">
    <pre><code>def rect(self, origin, dimensions, fill=False, color=0xF):
    '''Draws a rectangle in the framebuffer.
    The `origin` is the lower left position of the rectangle.  The
    `dimensions` is a 2-tuple of the width and height.  A width and height
    of 1 would be a 1 point rectangle.
    If `fill` is True, then the interior of the rectanle will be filled.
    Otherwise, only the outside edge of the rectandle will be drawn.  The
    rectangle is drawn in the given `color`.
    '''
    x, y = origin
    width, height = dimensions
    if fill:
        for x_offset in range(width):
            self.line((x + x_offset, y), (x + x_offset, y + height - 1), color)
    else:
        self.line((x, y), (x, y + height - 1), color)
        self.line((x, y + height - 1), (x + width - 1, y + height - 1), color)
        self.line((x + width - 1, y + height - 1), (x + width - 1, y), color)
        self.line((x + width - 1, y), (x, y), color)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="rstem.led_matrix.FrameBuffer.show">
    <p>def <span class="ident">show</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Send the framebuffer to the LED Matrices.</p>
<p>Sends the current framebuffer to the LED Matrices over the SPI bus,
according to the layout defined when the framebuffer was initialized.
This will cause the framebuffer to be displayed on the LED Matrix(es).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rstem.led_matrix.FrameBuffer.show', this);">Show source &equiv;</a></p>
  <div id="source-rstem.led_matrix.FrameBuffer.show" class="source">
    <pre><code>def show(self):
    '''Send the framebuffer to the LED Matrices.
    Sends the current framebuffer to the LED Matrices over the SPI bus,
    according to the layout defined when the framebuffer was initialized.
    This will cause the framebuffer to be displayed on the LED Matrix(es).
    '''
    bitstream = b''
    for xoff, yoff, quarter_clockwise_rotations in reversed(self.matrix_layout):
        forward = range(8)
        backward = list(reversed(forward))
        if quarter_clockwise_rotations == 0:
            flat = [self.fb[xoff + x][yoff + y] for x in forward for y in forward]
        elif quarter_clockwise_rotations == 1:
            flat = [self.fb[xoff + x][yoff + y] for y in backward for x in forward]
        elif quarter_clockwise_rotations == 2:
            flat = [self.fb[xoff + x][yoff + y] for x in backward for y in backward]
        elif quarter_clockwise_rotations == 3:
            flat = [self.fb[xoff + x][yoff + y] for y in forward for x in backward]
        else:
            raise RuntimeException('Internal Error: Invalid rotation')
        even = flat[::2]
        odd = flat[1::2]
        bitstream += bytes(b[0] | (b[1] << 4) for b in zip(even, odd))
    FrameBuffer.chip_enable.on()
    led_driver.send(bitstream)
    FrameBuffer.chip_enable.off()
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="rstem.led_matrix.FrameBuffer.fb" class="name">var <span class="ident">fb</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="rstem.led_matrix.FrameBuffer.height" class="name">var <span class="ident">height</span></p>
            

            
  
    <div class="desc"><p>Returns the height of the framebuffer.</p>
<p>The height depends upon the matrix layout.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="rstem.led_matrix.FrameBuffer.matrix_layout" class="name">var <span class="ident">matrix_layout</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="rstem.led_matrix.FrameBuffer.width" class="name">var <span class="ident">width</span></p>
            

            
  
    <div class="desc"><p>Returns the width of the framebuffer.</p>
<p>The width depends upon the matrix layout.</p></div>
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="rstem.led_matrix.Sprite" class="name">class <span class="ident">Sprite</span></p>
      
  
    <div class="desc"><p>A Sprite (2-dimensional bitmapped image) object.</p>
<p>A <code>Sprite</code> is drawable on the LED Matrix <code>FrameBuffer</code> with the
<code>FrameBuffer</code>'s <code>draw()</code> function.  <code>Sprite</code>s support tranparency.</p>
<p>Two sprites of the same hieght can be added togther, creating a new
horizontally concatenated composite sprite.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rstem.led_matrix.Sprite', this);">Show source &equiv;</a></p>
  <div id="source-rstem.led_matrix.Sprite" class="source">
    <pre><code>class Sprite(object):
    '''A Sprite (2-dimensional bitmapped image) object.

    A `Sprite` is drawable on the LED Matrix `FrameBuffer` with the
    `FrameBuffer`'s `draw()` function.  `Sprite`s support tranparency.

    Two sprites of the same hieght can be added togther, creating a new
    horizontally concatenated composite sprite.
    '''
    def __init__(self, image):
        '''Creates a `Sprite` object from the given `image`.
        
        The `image` defines the bitmap of the `Sprite`.  It is a string
        that contains one line for each row in the `Sprite`.  Each line should
        contains the same number of valid color characters.  All whitespace,
        including blank lines, is ignored.  

        Alternatively, `image` can be a Sprite, and then a new Sprite object
        will be created with the same bitmap of the given `image`.

        Each character in the `image` represents one pixel of the
        `Sprite`.  The characters must be either single hex digits representing
        the color (0-9, a-f, A-F) or - (dash) to represent transparency.

        For example, the following string would define a 3x5 letter P, with a transparent center
        of the P:

            f f f
            f - f
            f f f
            f 0 0
            f 0 0
        '''
        if isinstance(image, Sprite):
            image = str(image)

        # Remove whitespace from lines
        lines = (re.sub('\s', '', line) for line in image.splitlines())
        # remove blank lines
        lines = (line for line in lines if line)
        # Convert chars to integer colors
        reversed_transposed_bitmap = [[_to_color(color) for color in line] for line in lines]
        # Reverse and transpose array
        transposed_bitmap = list(reversed(reversed_transposed_bitmap))
        self.original_bitmap = [list(z) for z in zip(*transposed_bitmap)]

        self.reset()

    @classmethod
    def from_file(cls, filename):
        with open(filename) as f:
            s = cls(f.read())
        return s
        
    def _bitmap(self):
        return self.bitmap

    @property
    def width(self):
        '''Returns the width of the sprite.
        '''
        return len(self.bitmap)

    @property
    def height(self):
        '''Returns the height of the sprite.
        '''
        return len(self.bitmap[0])

    def __add__(self, sprite):
        if self.height != sprite.height:
            raise ValueError("Can only add sprites of the same height")
        self.bitmap += sprite.bitmap
        return self

    def _recreate_bitmap(self, xrange, yrange):
        yrange = list(yrange)
        self.bitmap = [[self.bitmap[x][y] for y in yrange] for x in xrange]

    def crop(self, origin=(0,0), dimensions=None):
        '''In-place crop of the sprite.

        Returns itself, so this function can be chained.
        '''
        x, y = origin
        if x >= self.width:
            raise IndexError('Origin X is greater than Sprite width')
        if y >= self.height:
            raise IndexError('Origin Y is greater than Sprite height')

        try:
            width, height = dimensions
        except TypeError:
            width, height = self.width, self.height

        xrange = range(x, min(x + width, self.width))
        yrange = range(y, min(y + height, self.height))
        self._recreate_bitmap(xrange, yrange)
        return self

    def rotate(self, angle=90):
        '''In-place rotation of the sprite.

        `angle` must be a multiple of 90.

        Returns itself, so this function can be chained.
        '''
        quarter_clockwise_rotations = _quarter_clockwise_rotations(angle)
        if quarter_clockwise_rotations == 0:
            xrange, yrange = range(self.width), range(self.height)
            transposed = False
        elif quarter_clockwise_rotations == 1:
            xrange, yrange = range(self.width), reversed(range(self.height))
            transposed = True
        elif quarter_clockwise_rotations == 2:
            xrange, yrange = reversed(range(self.width)), reversed(range(self.height))
            transposed = False
        elif quarter_clockwise_rotations == 3:
            xrange, yrange = reversed(range(self.width)), range(self.height)
            transposed = True
        else:
            raise RuntimeException('Internal Error: Invalid rotation')
        self._recreate_bitmap(xrange, yrange)
        if transposed:
            self.bitmap = [list(z) for z in zip(*self.bitmap)]
        return self
        
    def flip(self, vertical=False):
        '''In-place horizontal (default) or vertical flip of the sprite.

        Returns itself, so this function can be chained.
        '''
        if vertical:
            xrange, yrange = range(self.width), reversed(range(self.height))
        else:
            xrange, yrange = reversed(range(self.width)), range(self.height)
        self._recreate_bitmap(xrange, yrange)
        return self

    def __str__(self):
        return _color_array_to_str(self.bitmap, self.height, self.width)

    def reset(self):
        '''Undoes previous flip/rotate/crop/etc actions

        Returns itself, so this function can be chained.
        '''
        # When reset, bitmap is the original_bitmap.  Note, though, that
        # because this is a reference, self.bitmap should not be edited
        # in-place (even though it is mutable) - it should be replaced by any
        # operations that do work on it (e.g. flip()).
        self.bitmap = self.original_bitmap
        return self
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#rstem.led_matrix.Sprite">Sprite</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="rstem.led_matrix.Sprite.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, image)</p>
    </div>
    

    
  
    <div class="desc"><p>Creates a <code>Sprite</code> object from the given <code>image</code>.</p>
<p>The <code>image</code> defines the bitmap of the <code>Sprite</code>.  It is a string
that contains one line for each row in the <code>Sprite</code>.  Each line should
contains the same number of valid color characters.  All whitespace,
including blank lines, is ignored.  </p>
<p>Alternatively, <code>image</code> can be a Sprite, and then a new Sprite object
will be created with the same bitmap of the given <code>image</code>.</p>
<p>Each character in the <code>image</code> represents one pixel of the
<code>Sprite</code>.  The characters must be either single hex digits representing
the color (0-9, a-f, A-F) or - (dash) to represent transparency.</p>
<p>For example, the following string would define a 3x5 letter P, with a transparent center
of the P:</p>
<pre><code>f f f
f - f
f f f
f 0 0
f 0 0
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rstem.led_matrix.Sprite.__init__', this);">Show source &equiv;</a></p>
  <div id="source-rstem.led_matrix.Sprite.__init__" class="source">
    <pre><code>def __init__(self, image):
    '''Creates a `Sprite` object from the given `image`.
    
    The `image` defines the bitmap of the `Sprite`.  It is a string
    that contains one line for each row in the `Sprite`.  Each line should
    contains the same number of valid color characters.  All whitespace,
    including blank lines, is ignored.  
    Alternatively, `image` can be a Sprite, and then a new Sprite object
    will be created with the same bitmap of the given `image`.
    Each character in the `image` represents one pixel of the
    `Sprite`.  The characters must be either single hex digits representing
    the color (0-9, a-f, A-F) or - (dash) to represent transparency.
    For example, the following string would define a 3x5 letter P, with a transparent center
    of the P:
        f f f
        f - f
        f f f
        f 0 0
        f 0 0
    '''
    if isinstance(image, Sprite):
        image = str(image)
    # Remove whitespace from lines
    lines = (re.sub('\s', '', line) for line in image.splitlines())
    # remove blank lines
    lines = (line for line in lines if line)
    # Convert chars to integer colors
    reversed_transposed_bitmap = [[_to_color(color) for color in line] for line in lines]
    # Reverse and transpose array
    transposed_bitmap = list(reversed(reversed_transposed_bitmap))
    self.original_bitmap = [list(z) for z in zip(*transposed_bitmap)]
    self.reset()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="rstem.led_matrix.Sprite.crop">
    <p>def <span class="ident">crop</span>(</p><p>self, origin=(0, 0), dimensions=None)</p>
    </div>
    

    
  
    <div class="desc"><p>In-place crop of the sprite.</p>
<p>Returns itself, so this function can be chained.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rstem.led_matrix.Sprite.crop', this);">Show source &equiv;</a></p>
  <div id="source-rstem.led_matrix.Sprite.crop" class="source">
    <pre><code>def crop(self, origin=(0,0), dimensions=None):
    '''In-place crop of the sprite.
    Returns itself, so this function can be chained.
    '''
    x, y = origin
    if x >= self.width:
        raise IndexError('Origin X is greater than Sprite width')
    if y >= self.height:
        raise IndexError('Origin Y is greater than Sprite height')
    try:
        width, height = dimensions
    except TypeError:
        width, height = self.width, self.height
    xrange = range(x, min(x + width, self.width))
    yrange = range(y, min(y + height, self.height))
    self._recreate_bitmap(xrange, yrange)
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="rstem.led_matrix.Sprite.flip">
    <p>def <span class="ident">flip</span>(</p><p>self, vertical=False)</p>
    </div>
    

    
  
    <div class="desc"><p>In-place horizontal (default) or vertical flip of the sprite.</p>
<p>Returns itself, so this function can be chained.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rstem.led_matrix.Sprite.flip', this);">Show source &equiv;</a></p>
  <div id="source-rstem.led_matrix.Sprite.flip" class="source">
    <pre><code>def flip(self, vertical=False):
    '''In-place horizontal (default) or vertical flip of the sprite.
    Returns itself, so this function can be chained.
    '''
    if vertical:
        xrange, yrange = range(self.width), reversed(range(self.height))
    else:
        xrange, yrange = reversed(range(self.width)), range(self.height)
    self._recreate_bitmap(xrange, yrange)
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="rstem.led_matrix.Sprite.reset">
    <p>def <span class="ident">reset</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Undoes previous flip/rotate/crop/etc actions</p>
<p>Returns itself, so this function can be chained.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rstem.led_matrix.Sprite.reset', this);">Show source &equiv;</a></p>
  <div id="source-rstem.led_matrix.Sprite.reset" class="source">
    <pre><code>def reset(self):
    '''Undoes previous flip/rotate/crop/etc actions
    Returns itself, so this function can be chained.
    '''
    # When reset, bitmap is the original_bitmap.  Note, though, that
    # because this is a reference, self.bitmap should not be edited
    # in-place (even though it is mutable) - it should be replaced by any
    # operations that do work on it (e.g. flip()).
    self.bitmap = self.original_bitmap
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="rstem.led_matrix.Sprite.rotate">
    <p>def <span class="ident">rotate</span>(</p><p>self, angle=90)</p>
    </div>
    

    
  
    <div class="desc"><p>In-place rotation of the sprite.</p>
<p><code>angle</code> must be a multiple of 90.</p>
<p>Returns itself, so this function can be chained.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rstem.led_matrix.Sprite.rotate', this);">Show source &equiv;</a></p>
  <div id="source-rstem.led_matrix.Sprite.rotate" class="source">
    <pre><code>def rotate(self, angle=90):
    '''In-place rotation of the sprite.
    `angle` must be a multiple of 90.
    Returns itself, so this function can be chained.
    '''
    quarter_clockwise_rotations = _quarter_clockwise_rotations(angle)
    if quarter_clockwise_rotations == 0:
        xrange, yrange = range(self.width), range(self.height)
        transposed = False
    elif quarter_clockwise_rotations == 1:
        xrange, yrange = range(self.width), reversed(range(self.height))
        transposed = True
    elif quarter_clockwise_rotations == 2:
        xrange, yrange = reversed(range(self.width)), reversed(range(self.height))
        transposed = False
    elif quarter_clockwise_rotations == 3:
        xrange, yrange = reversed(range(self.width)), range(self.height)
        transposed = True
    else:
        raise RuntimeException('Internal Error: Invalid rotation')
    self._recreate_bitmap(xrange, yrange)
    if transposed:
        self.bitmap = [list(z) for z in zip(*self.bitmap)]
    return self
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="rstem.led_matrix.Sprite.height" class="name">var <span class="ident">height</span></p>
            

            
  
    <div class="desc"><p>Returns the height of the sprite.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="rstem.led_matrix.Sprite.original_bitmap" class="name">var <span class="ident">original_bitmap</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="rstem.led_matrix.Sprite.width" class="name">var <span class="ident">width</span></p>
            

            
  
    <div class="desc"><p>Returns the width of the sprite.</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="rstem.led_matrix.Sprite.from_file">
    <p>def <span class="ident">from_file</span>(</p><p>cls, filename)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rstem.led_matrix.Sprite.from_file', this);">Show source &equiv;</a></p>
  <div id="source-rstem.led_matrix.Sprite.from_file" class="source">
    <pre><code>@classmethod
def from_file(cls, filename):
    with open(filename) as f:
        s = cls(f.read())
    return s
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="rstem.led_matrix.Text" class="name">class <span class="ident">Text</span></p>
      
  
    <div class="desc"><p>A string of text writable to the framebuffer.</p>
<p><code>Text</code> is composed of a concatenated string of <code>Sprite</code>s, and as such can
use all the functions available to <code>Sprite</code>s.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rstem.led_matrix.Text', this);">Show source &equiv;</a></p>
  <div id="source-rstem.led_matrix.Text" class="source">
    <pre><code>class Text(Sprite):
    '''A string of text writable to the framebuffer.

    `Text` is composed of a concatenated string of `Sprite`s, and as such can
    use all the functions available to `Sprite`s.
    '''
    def __init__(self, message, char_spacing=1, font_name='5x7', font_dir=None):
        '''Create a `Text` object from a string.

        `message` is the text string.  Two fonts are supported: '3x5' and
        '5x7'.  Custom fonts can be created by making one sprite file for each
        letter in the font.  The `font_dir` can be changed from the default to
        point to a custom font.

        `char_spacing` is the number of blank pixels that are put between two
        characters in a string.
        '''
        with open(self._font_path(font_dir, font_name, message[0])) as f:
            super().__init__(f.read())
        if len(message) > 1:
            self.__add__(Sprite((('-' * char_spacing) + '\n') * self.height))
            self.__add__(Text(message[1:], char_spacing=char_spacing, font_name=font_name, font_dir=font_dir))

    @classmethod
    def from_file(cls, filename):
        super().from_file(filename)
        
    @classmethod
    def font_list(cls, font_dir=None):
        font_dir = cls._font_dir(font_dir)
        return [d for d in os.glob(font_dir) if os.path.isdir(d)]

    @staticmethod
    def _font_dir(font_dir=None):
        if font_dir is None:
            this_dir, this_filename = os.path.split(__file__)
            font_dir = os.path.join(this_dir, 'font')
            
        if not os.path.isdir(font_dir):
            raise IOError('Font path does not exist.')

        return font_dir
        
    def _font_path(self, font_dir, font_name, char):
        font_path = os.path.join(self._font_dir(), font_name)
        unknown_font_path = os.path.join(font_path, 'unknown.spr')
        
        if char.isdigit():
            font_path = os.path.join(font_path, 'numbers', char + '.spr')
        elif char.isupper():
            font_path = os.path.join(font_path, 'upper', char + '.spr')
        elif char.islower():
            font_path = os.path.join(font_path, 'lower', char + '.spr')
        elif char.isspace():
            font_path = os.path.join(font_path, 'space.spr')
        else:
            font_path = os.path.join(font_path, 'misc', str(ord(char)) + '.spr')
            
        if not os.path.isfile(font_path):
            return unknown_font_path

        return font_path
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#rstem.led_matrix.Text">Text</a></li>
          <li><a href="#rstem.led_matrix.Sprite">Sprite</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="rstem.led_matrix.Text.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, message, char_spacing=1, font_name=&#39;5x7&#39;, font_dir=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Create a <code>Text</code> object from a string.</p>
<p><code>message</code> is the text string.  Two fonts are supported: '3x5' and
'5x7'.  Custom fonts can be created by making one sprite file for each
letter in the font.  The <code>font_dir</code> can be changed from the default to
point to a custom font.</p>
<p><code>char_spacing</code> is the number of blank pixels that are put between two
characters in a string.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rstem.led_matrix.Text.__init__', this);">Show source &equiv;</a></p>
  <div id="source-rstem.led_matrix.Text.__init__" class="source">
    <pre><code>def __init__(self, message, char_spacing=1, font_name='5x7', font_dir=None):
    '''Create a `Text` object from a string.
    `message` is the text string.  Two fonts are supported: '3x5' and
    '5x7'.  Custom fonts can be created by making one sprite file for each
    letter in the font.  The `font_dir` can be changed from the default to
    point to a custom font.
    `char_spacing` is the number of blank pixels that are put between two
    characters in a string.
    '''
    with open(self._font_path(font_dir, font_name, message[0])) as f:
        super().__init__(f.read())
    if len(message) > 1:
        self.__add__(Sprite((('-' * char_spacing) + '\n') * self.height))
        self.__add__(Text(message[1:], char_spacing=char_spacing, font_name=font_name, font_dir=font_dir))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="rstem.led_matrix.Text.crop">
    <p>def <span class="ident">crop</span>(</p><p>self, origin=(0, 0), dimensions=None)</p>
    </div>
    

    
  
    <div class="desc"><p>In-place crop of the sprite.</p>
<p>Returns itself, so this function can be chained.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rstem.led_matrix.Text.crop', this);">Show source &equiv;</a></p>
  <div id="source-rstem.led_matrix.Text.crop" class="source">
    <pre><code>def crop(self, origin=(0,0), dimensions=None):
    '''In-place crop of the sprite.
    Returns itself, so this function can be chained.
    '''
    x, y = origin
    if x >= self.width:
        raise IndexError('Origin X is greater than Sprite width')
    if y >= self.height:
        raise IndexError('Origin Y is greater than Sprite height')
    try:
        width, height = dimensions
    except TypeError:
        width, height = self.width, self.height
    xrange = range(x, min(x + width, self.width))
    yrange = range(y, min(y + height, self.height))
    self._recreate_bitmap(xrange, yrange)
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="rstem.led_matrix.Text.flip">
    <p>def <span class="ident">flip</span>(</p><p>self, vertical=False)</p>
    </div>
    

    
  
    <div class="desc"><p>In-place horizontal (default) or vertical flip of the sprite.</p>
<p>Returns itself, so this function can be chained.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rstem.led_matrix.Text.flip', this);">Show source &equiv;</a></p>
  <div id="source-rstem.led_matrix.Text.flip" class="source">
    <pre><code>def flip(self, vertical=False):
    '''In-place horizontal (default) or vertical flip of the sprite.
    Returns itself, so this function can be chained.
    '''
    if vertical:
        xrange, yrange = range(self.width), reversed(range(self.height))
    else:
        xrange, yrange = reversed(range(self.width)), range(self.height)
    self._recreate_bitmap(xrange, yrange)
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="rstem.led_matrix.Text.reset">
    <p>def <span class="ident">reset</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Undoes previous flip/rotate/crop/etc actions</p>
<p>Returns itself, so this function can be chained.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rstem.led_matrix.Text.reset', this);">Show source &equiv;</a></p>
  <div id="source-rstem.led_matrix.Text.reset" class="source">
    <pre><code>def reset(self):
    '''Undoes previous flip/rotate/crop/etc actions
    Returns itself, so this function can be chained.
    '''
    # When reset, bitmap is the original_bitmap.  Note, though, that
    # because this is a reference, self.bitmap should not be edited
    # in-place (even though it is mutable) - it should be replaced by any
    # operations that do work on it (e.g. flip()).
    self.bitmap = self.original_bitmap
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="rstem.led_matrix.Text.rotate">
    <p>def <span class="ident">rotate</span>(</p><p>self, angle=90)</p>
    </div>
    

    
  
    <div class="desc"><p>In-place rotation of the sprite.</p>
<p><code>angle</code> must be a multiple of 90.</p>
<p>Returns itself, so this function can be chained.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rstem.led_matrix.Text.rotate', this);">Show source &equiv;</a></p>
  <div id="source-rstem.led_matrix.Text.rotate" class="source">
    <pre><code>def rotate(self, angle=90):
    '''In-place rotation of the sprite.
    `angle` must be a multiple of 90.
    Returns itself, so this function can be chained.
    '''
    quarter_clockwise_rotations = _quarter_clockwise_rotations(angle)
    if quarter_clockwise_rotations == 0:
        xrange, yrange = range(self.width), range(self.height)
        transposed = False
    elif quarter_clockwise_rotations == 1:
        xrange, yrange = range(self.width), reversed(range(self.height))
        transposed = True
    elif quarter_clockwise_rotations == 2:
        xrange, yrange = reversed(range(self.width)), reversed(range(self.height))
        transposed = False
    elif quarter_clockwise_rotations == 3:
        xrange, yrange = reversed(range(self.width)), range(self.height)
        transposed = True
    else:
        raise RuntimeException('Internal Error: Invalid rotation')
    self._recreate_bitmap(xrange, yrange)
    if transposed:
        self.bitmap = [list(z) for z in zip(*self.bitmap)]
    return self
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="rstem.led_matrix.Text.height" class="name">var <span class="ident">height</span></p>
            

            
  
    <div class="desc"><p>Returns the height of the sprite.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="rstem.led_matrix.Text.width" class="name">var <span class="ident">width</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#rstem.led_matrix.Sprite">Sprite</a></code>.<code><a href="#rstem.led_matrix.Sprite.width">width</a></code>
    </p>

            
  
    <div class="desc inherited"><p>Returns the width of the sprite.</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="rstem.led_matrix.Text.font_list">
    <p>def <span class="ident">font_list</span>(</p><p>cls, font_dir=None)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rstem.led_matrix.Text.font_list', this);">Show source &equiv;</a></p>
  <div id="source-rstem.led_matrix.Text.font_list" class="source">
    <pre><code>@classmethod
def font_list(cls, font_dir=None):
    font_dir = cls._font_dir(font_dir)
    return [d for d in os.glob(font_dir) if os.path.isdir(d)]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="rstem.led_matrix.Text.from_file">
    <p>def <span class="ident">from_file</span>(</p><p>cls, filename)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-rstem.led_matrix.Text.from_file', this);">Show source &equiv;</a></p>
  <div id="source-rstem.led_matrix.Text.from_file" class="source">
    <pre><code>@classmethod
def from_file(cls, filename):
    super().from_file(filename)
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
